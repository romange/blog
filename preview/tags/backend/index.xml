<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>backend on These are the wrong sort of bees</title><link>https://romange.github.io/blog/preview/tags/backend/</link><description>Recent content in backend on These are the wrong sort of bees</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 30 Jan 2022 20:00:00 +0200</lastBuildDate><atom:link href="https://romange.github.io/blog/preview/tags/backend/index.xml" rel="self" type="application/rss+xml"/><item><title>Redis Analysis - Part 2: Simplicity</title><link>https://romange.github.io/blog/preview/2022/01/30/redis-analysis-part-2-simplicity/</link><pubDate>Sun, 30 Jan 2022 20:00:00 +0200</pubDate><guid>https://romange.github.io/blog/preview/2022/01/30/redis-analysis-part-2-simplicity/</guid><description>&lt;p>Let&amp;rsquo;s talk about the simplicity of Redis.
Redis was initially designed as a simple store, and it seems that its APIs achieved this goal.
Unfortunately, Redis&amp;rsquo;s simple design makes it unreliable and difficult to manage in production.&lt;/p>
&lt;p>So the question is - what simplicity means to you as a datastore user?&lt;/p></description></item><item><title>Reloading data structures under high throughput</title><link>https://romange.github.io/blog/preview/2017/09/29/reloading-data-structures-under-high-throughput/</link><pubDate>Fri, 29 Sep 2017 15:46:55 +0300</pubDate><guid>https://romange.github.io/blog/preview/2017/09/29/reloading-data-structures-under-high-throughput/</guid><description>&lt;p>Suppose you have a multi-threaded server that serves tens of thousands read queries per second. Those queries use a shared data-structure or index that is mostly immutable during the server run with the exception of periodic index reloads. How do you implement data reloads in that server while keeping it live and kicking in production?&lt;/p></description></item></channel></rss>