<!doctype html><html lang=en-us><head><title>Redis Analysis - Part 2: Simplicity &#183; These are the wrong sort of bees</title><meta name=generator content="Hugo 0.105.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=author content="Roman Gershman"><meta name=description content="The wrong sort of bees"><link rel=canonical href=https://romange.github.io/blog/preview/2022/01/30/redis-analysis-part-2-simplicity/><link rel=icon href=https://romange.github.io/blog/preview/favicon.ico><link rel=apple-touch-icon href=https://romange.github.io/blog/preview/apple-touch-icon.png><link rel=stylesheet href=https://romange.github.io/blog/preview/css/style.css><link rel=stylesheet href=https://romange.github.io/blog/preview/css/font-awesome.min.css><link rel=stylesheet href=https://romange.github.io/blog/preview/css/monokai.css><link rel=stylesheet href=https://romange.github.io/blog/preview/fancybox/jquery.fancybox.css><link href='https://fonts.googleapis.com/css?family=Open+Sans:400italic,400,600' rel=stylesheet type=text/css><link href='https://fonts.googleapis.com/css?family=Source+Code+Pro' rel=stylesheet type=text/css><meta property="og:title" content="Redis Analysis - Part 2: Simplicity "><meta property="og:description" content="Let&rsquo;s talk about the simplicity of Redis.
Redis was initially designed as a simple store, and it seems that its APIs achieved this goal.
Unfortunately, Redis&rsquo;s simple design makes it unreliable and difficult to manage in production.
So the question is - what simplicity means to you as a datastore user?"><meta property="og:type" content="article"><meta property="og:url" content="https://romange.github.io/blog/preview/2022/01/30/redis-analysis-part-2-simplicity/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-01-30T20:00:00+02:00"><meta property="article:modified_time" content="2022-01-30T20:00:00+02:00"><meta itemprop=name content="Redis Analysis - Part 2: Simplicity "><meta itemprop=description content="Let&rsquo;s talk about the simplicity of Redis.
Redis was initially designed as a simple store, and it seems that its APIs achieved this goal.
Unfortunately, Redis&rsquo;s simple design makes it unreliable and difficult to manage in production.
So the question is - what simplicity means to you as a datastore user?"><meta itemprop=datePublished content="2022-01-30T20:00:00+02:00"><meta itemprop=dateModified content="2022-01-30T20:00:00+02:00"><meta itemprop=wordCount content="1519"><meta itemprop=keywords content="redis,backend,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis Analysis - Part 2: Simplicity "><meta name=twitter:description content="Let&rsquo;s talk about the simplicity of Redis.
Redis was initially designed as a simple store, and it seems that its APIs achieved this goal.
Unfortunately, Redis&rsquo;s simple design makes it unreliable and difficult to manage in production.
So the question is - what simplicity means to you as a datastore user?"><meta name=twitter:site content="@romanger"><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js></script></head><body><div class=container><div id=container><header id=header><div id=header-main class=header-inner><div class=outer><a href=https://romange.github.io/blog/preview/ id=logo><i class=logo style=background-image:url(https://romange.github.io/blog/preview/css/images/7.png)></i>
<span class=site-title>These are the wrong sort of bees</span></a><nav id=main-nav><a class=main-nav-link href=https://romange.github.io/blog/preview/tags/>Tags</a>
<a class=main-nav-link href=https://romange.github.io/blog/preview/about/>About</a></nav><nav id=sub-nav><div class=profile id=profile-nav><a id=profile-anchor href=javascript:;><img class=avatar src=https://romange.github.io/blog/preview/css/images/avatar.png><i class="fa fa-caret-down"></i></a></div></nav><div id=search-form-wrap><form action=//google.com/search method=get accept-charset=utf-8 class=search-form><input type=search name=q class=search-form-input placeholder=Search>
<button type=submit class=search-form-submit></button>
<input type=hidden name=sitesearch value=https://romange.github.io/blog/preview/></form></div></div></div><div id=main-nav-mobile class="header-sub header-inner"><table class="menu outer"><tbody><tr><td><a class=main-nav-link href=https://romange.github.io/blog/preview/tags/>Tags</a></td><td><a class=main-nav-link href=https://romange.github.io/blog/preview/about/>About</a></td><td><form action=//google.com/search method=get accept-charset=utf-8 class=search-form><input type=search name=q class=search-form-input placeholder=Search>
<input type=hidden name=sitesearch value=https://romange.github.io/blog/preview/></form></td></tr></tbody></table></div></header><div class=outer><aside id=profile><div class="inner profile-inner"><div class="base-info profile-block"><img id=avatar src="https://www.gravatar.com/avatar/4a203a48eb1cdb1b8c47d008f0c139c9?s=100&d=identicon"><h2 id=name>Roman Gershman</h2><h3 id=title>Software Engineer</h3><span id=location><i class="fa fa-map-marker"></i>Tel Aviv</span>
<a id=follow href=https://github.com/romange>Follow</a></div><div class="article-info profile-block"><div class=article-info-block>15
<span>Posts</span></div><div class=article-info-block>17
<span>Tags</span></div></div><div class="profile-block social-links"><table><tr><td><a href=//github.com/romange target=_blank title=GitHub><i class="fa fa-github"></i></a></td><td><a href=//linkedin.com/in/romange target=_blank title=LinkedIn><i class="fa fa-linkedin"></i></a></td><td><a href=//stackoverflow.com/users/romange target=_blank title="Stack Overflow"><i class="fa fa-stack-overflow"></i></a></td><td><a href=//twitter.com/romanger target=_blank title=Twitter><i class="fa fa-twitter"></i></a></td><td><a href=https://romange.github.io/blog/preview/index.xml target=_blank title=RSS><i class="fa fa-rss"></i></a></td></tr></table></div></div></aside><section id=main><article id=page-undefined class="article article-type-page" itemscope itemprop=blogPost><div class=article-inner><img src=https://romange.github.io/blog/preview/banners/simple.jpg class=article-banner><header class=article-header><a href=https://romange.github.io/blog/preview/2022/01/30/redis-analysis-part-2-simplicity/><h1 class=article-title itemprop=name>Redis Analysis - Part 2: Simplicity</h1></a><div class=article-meta><div class=article-date><i class="fa fa-calendar"></i>
<time datetime="2022-01-30 20:00:00 +0200 +0200" itemprop=datePublished>Jan 30nd 2022</time>
&#183;
1519
words
&#183;
8
minute read</div><div class=article-category><i class="fa fa-tags"></i>
<a class=article-category-link href=https://romange.github.io/blog/preview/tags/redis>redis</a>
&#183;
<a class=article-category-link href=https://romange.github.io/blog/preview/tags/backend>backend</a></div></div></header><div class=article-entry itemprop=articleBody><p>Let&rsquo;s talk about the simplicity of Redis.
Redis was initially designed as a simple store, and it seems that its APIs achieved this goal.
Unfortunately, Redis&rsquo;s simple design makes it unreliable and difficult to manage in production.</p><p>So the question is - what simplicity means to you as a datastore user?</p><p>Before diving into Redis specifics, a disclosure: some of the problems I mention below
do not show up for small workloads. For those of you, who have managed Redis instances
larger than 12GB, please answer the following questions:</p><ul><li><p>There are eight Redis cache eviction policies. How well do you know them? Are you happy with either
one of them?</p></li><li><p>How confident are you when you need to change Redis settings, especially
those that control its memory consumption? Can you guarantee what its peak memory usage will be?</p></li><li><p>Have you ever needed to debug an unresponsive Redis instance or a its OOM crash? How easy was it?</p></li><li><p>Have you ever observed connection overload events when multiple clients connect to a redis instance?</p></li></ul><p>Fourteen years after Redis&rsquo;s inception, we&rsquo;ve established that the engineering community demands
a simple, low-latency Redis-like API that compliments relational databases. However, the community is unlikely to settle with a fragile technology that is hard to manage. API simplicity does not mean that the foundation should not be solid.</p><p>I was fortunate to observe Redis and Memcached usage globally, so
my opinion was shaped by looking at the whole range of workloads:
I&rsquo;ve seen how those &ldquo;simple&rdquo; design decisions in Redis
caused a sub-optimal but manageable quirks with 4-16GB workloads, made it painful at 64GB scale,
and caused frustration and a lack of trust with 100+ GB workloads.</p><h2 id=redis-caching>Redis Caching</h2><p>I mentioned cache policy already. It&rsquo;s one of more significant settings in Redis when used as a cache (a pretty popular use-case for Redis). In a perfect world, a regular user of Redis would love to have a magical cache that does the following:</p><ul><li>Reclaims expired items instead of growing in memory. btw, this requirement holds for non-cache scenarios as well.</li><li>similarly, does not evict non-expired entries if there is a sinificant number of expired items that
could be evicted instead.</li><li>maximizes hit-ratio in a robust manner by keeping entries that are most likely to be hit in the future.</li></ul><p>A normal user does not want to know what LFU or LRU is, or why Redis implements
guesstimate of those heuristics or why it can not evict expired items efficiently.
In reality, not only that the user is expected to know the internal implementation details
of the Redis cache algorithms, he also needs to decide between eight &ldquo;simple&rdquo; options of <code>maxmemory-policy</code> setting.<figure><img src=/img/choices.jpg alt="redis settings" width=350px></figure></p><h2 id=persistence>Persistence</h2><p>If I had to pick a single design choice that looked &ldquo;simple&rdquo; at the time
yet had a substantial negative impact on the reliability of the whole system and the complexity of other features - it would be the fork-based BGSAVE command. The BGSAVE algorithm allows Redis to produce a point-in-time snapshotting of in-memory data or sync with its secondary replica. Redis does it by forking the serialization routine into a child process. By doing so, this child process gets an immutable, point-in-time snapshot of its parent process memory from Linux for &ldquo;free&rdquo;. Redis relies on Linux property that does not copy the physical memory during <code>fork()</code> but uses lazy Copy-On-Write operation instead.</p><p>Using the OS to achieve consistent snapshot isolation looks like an elegant choice at first sight. However, there are some serious problems with this approach:</p><ol><li><strong>Lack of back-pressure</strong> When the Redis parent process mutates its entries, it in fact duplicates the Linux memory pages with CoW. CoW is transparent to the parent process; therefore
the Redis memory component has a hard time estimating its actual memory usage.
And even if it did, there is no efficient mechanism in Redis to &ldquo;postpone&rdquo; or stall the incoming writes - the execution thread must progress with the flow. Under the heavy writes, this will easily
cause OOM crashes. <img src=/img/bgsave.gif alt=bgsave></li><li><strong>Unbounded memory overhead</strong> In the worst case, both child and parent processes could double
Redis physical memory. Unfortunately, it does not stop there with replica syncs: the parent must also hold the replication log of mutations during the snapshot, which grows in memory until the sync completes. In addition, the parent dataset can grow beyond its initial size because the user continues adding items.
These factors can contribute to RSS usage spiking wildly under different write loads or database sizes. All this makes it very hard to estimate the
maximum memory usage for Redis.<figure><img src=/img/boromir.jpg alt="boromir knows" width=300px></figure></li><li><strong>Linux large pages</strong> Enabling large pages usually improves the database performance; however, with Redis and bgsave, huge pages would create high write amplification - a tiny write would cause 2MB or 1GB CoW. This would quickly cause 100% memory overhead and major latency spikes during writes.</li><li><strong>Bad interactions with other Redis features</strong> Ask Redis maintainers how hard it was to implement TLS support in Redis 6. The seemingly unrelated feature had several problems due to how the TLS session interacted with the <code>fork()</code> call. As a result: TLS in Redis has mediocre performance.</li></ol><p>So far, I&rsquo;ve mentioned a few stability problems with Redis that are impossible to fix
with the current Redis architecture. There is a long tail of additional problems that hurt Redis reliability, impact its resource usage or obscure its API guarantees. Here are some of them in random order:</p><ul><li>Unreliable replica syncs: if the master&rsquo;s replication buffer overflows during replica sync,
the replica will retry the whole synchronization flow, possibly entering the infinite cycle of never-ending attempts.</li><li>Unreliable timeouts in blocking commands: blocking commands can expire with timeouts much larger than specified.</li><li>Uncontrolled freezes: commands like <code>FLUSHDB</code> will &ldquo;stop the world&rdquo; during their execution.
This means Redis may completely stall the processing of ongoing requests for minutes or longer.</li><li>LUA stalling: a similar problem with unresponsiveness exists when running bad LUA scripts.
Moreover, even good scripts may cause significant delays to other concurrent requests due to the sequential nature of Redis execution.</li><li>PUB/SUB is unreliable and prone to data loss when a SUB client disconnects.</li></ul><h2 id=fight-against-complexity>Fight against complexity</h2><p>I think it&rsquo;s time to redesign the system that once challenged traditional databases but nowadays suffers
from complexity itself.</p><p>Lately, I&rsquo;ve been working on a novel design of a cache and dictionary
data structures that could be the foundation stones for the next-generation memory store.
The work is still in progress, but it already shows some promising results.
The cache design is so novel that I think it deserves a blog post of its own. Therefore, today I will share just the basic characteristics of the underlying dictionary.</p><p>Below you can see a Redis 6.2 vs my experimental store (POC), both running on a dedicated 64-cpu n2d instance in GCP.</p><p>I run the same three commands on both servers: <code>debug populate</code>, <code>save</code> and <code>flushdb</code>. <code>populate</code> is interesting because it demonstrates the raw efficiency of the underlying engine,
without bottlenecks like networking. <code>save</code> and <code>flushdb</code> are interesting because both
are &ldquo;stop the world&rdquo; commands that must process the whole database and their performance directly affects
database robustness.</p><figure><img src=/img/redis_table.png alt="redis 6.2" width=350px></figure><p>As you can see it takes almost 180s to create 200M items in Redis. What&rsquo;s remarkable about this number
is that it sets an upper bound on write throughput limit for Redis: no matter how big the Redis server is,
it won&rsquo;t be able to go faster than ~1.1M records a second because records creation is always done entirely in a single thread. Saving 200M records takes 150s which shows how quickly a server can persist its data or replicate itself to a replica. Note the gap: those 200M items take up 17GB of RAM,
hence Redis moves 17GB in 150s or 110MB/s (for comparison, the slowest hdd in AWS (sc1)
reaches 250MB/s and in GCP (pd-standard) reaches 400MB/s).
Finally, <code>flushdb</code> demonstrates that a simple &ldquo;empty my store&rdquo;
operation may be cpu-intensive, and completely stall other requests for almost 3 minutes!
Not so simple anymore.</p><p>This snapshot below is the POC store under development.<figure><img src=/img/df_table2.png alt=POC width=500px></figure>You can see that the same commands run an order of magnitude faster. The result is achieved in part
because of the <a href=https://romange.github.io/blog/preview/2021/12/09/redis-analysis-part-1-threading-model/>shared-nothing architecture</a> that distributes operations across cpus but also due to novel
dictionary design. Btw, you can see that <code>flushdb</code> operation was not timed - <code>redis-cli</code> does not show
latencies of &ldquo;fast&rdquo; operations below 500ms. Hence, we can conclude that <code>flushdb</code> was at least 350 times faster in this case. If you compare <code>used_memory_human</code> metric, you can see that Redis
required almost twice more RAM than the POC (16.9GB vs 9.5GB).</p><p>There is a lot more to cover. For example, Redis <code>SAVE</code> stalls the processing of all requests,
similarly to <code>FLUSHDB</code> . In contrast, the new store runs it concurrently with the rest of the traffic while still producing a consistent point-in-time snapshot. In other words, it provides <code>BGSAVE</code> product experience with the reliability of <code>SAVE</code>.</p><p>If we combine the long tail of improvements that come from a new design, we will get a product
that redefines what simplicity and ease of use mean for an in-memory database world.</p></div><footer class=article-footer><a data-url=https://romange.github.io/blog/preview/2022/01/30/redis-analysis-part-2-simplicity/ data-id=eed3ea294ea4af8047687123bba03b1a class=article-share-link><i class="fa fa-share"></i>
Share</a>
<a href=https://romange.github.io/blog/preview/2022/01/30/redis-analysis-part-2-simplicity/#disqus_thread class=article-comment-link>Comments</a>
<script>(function(e){if(typeof __SHARE_BUTTON_BINDED__=="undefined"||!__SHARE_BUTTON_BINDED__)__SHARE_BUTTON_BINDED__=!0;else return;e("body").on("click",function(){e(".article-share-box.on").removeClass("on")}).on("click",".article-share-link",function(t){t.stopPropagation();var n,c,o=e(this),a=o.attr("data-url"),s=encodeURIComponent(a),i="article-share-box-"+o.attr("data-id"),r=o.offset();if(e("#"+i).length){if(n=e("#"+i),n.hasClass("on")){n.removeClass("on");return}}else c=['<div id="'+i+'" class="article-share-box">','<input class="article-share-input" value="'+a+'">','<div class="article-share-links">','<a href="https://twitter.com/intent/tweet?url='+s+'" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>','<a href="https://www.facebook.com/sharer.php?u='+s+'" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>','<a href="http://pinterest.com/pin/create/button/?url='+s+'" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>','<a href="https://plus.google.com/share?url='+s+'" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',"</div>","</div>"].join(""),n=e(c),e("body").append(n);e(".article-share-box.on").hide(),n.css({top:r.top+25,left:r.left}).addClass("on")}).on("click",".article-share-box",function(e){e.stopPropagation()}).on("click",".article-share-box-input",function(){e(this).select()}).on("click",".article-share-box-link",function(e){e.preventDefault(),e.stopPropagation(),window.open(this.href,"article-share-box-window-"+Date.now(),"width=500,height=450")})})(jQuery)</script></footer></div><nav id=article-nav><a href=https://romange.github.io/blog/preview/2021/12/09/redis-analysis-part-1-threading-model/ id=article-nav-older class=article-nav-link-wrap><strong class=article-nav-caption>Older</strong><div class=article-nav-title>Redis Analysis - Part 1: Threading model</div></a><a href=https://romange.github.io/blog/preview/2022/06/23/dragonfly-cache-design/ id=article-nav-newer class=article-nav-link-wrap><strong class=article-nav-caption>Newer</strong><div class=article-nav-title>Dragonfly Cache Design</div></a></nav></article><section id=comments><div id=disqus_thread><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//romange.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></section></section><aside id=sidebar><div class=widget-wrap><h3 class=widget-title>Recents</h3><div class=widget><ul id=recent-post><li><div class=item-thumbnail><a href=https://romange.github.io/blog/preview/2022/10/26/balanced-vs-unbalanced/ class=thumbnail><span style=background-image:url(https://romange.github.io/blog/preview/banners/floaty-jerry.png) alt="Redis Analysis - Part 2: Simplicity " class=thumbnail-image></span></a></div><div class=item-inner><p class=item-title><a href=https://romange.github.io/blog/preview/2022/10/26/balanced-vs-unbalanced/ class=title>balanced vs unbalanced</a></p><p class=item-date><time datetime="2022-10-26 09:24:23 +0300 +0300" itemprop=datePublished>Oct 26nd 2022</time></p></div></li><li><div class=item-thumbnail><a href=https://romange.github.io/blog/preview/2022/06/23/dragonfly-cache-design/ class=thumbnail><span class="thumbnail-image thumbnail-none"></span></a></div><div class=item-inner><p class=item-title><a href=https://romange.github.io/blog/preview/2022/06/23/dragonfly-cache-design/ class=title>Dragonfly Cache Design</a></p><p class=item-date><time datetime="2022-06-23 12:00:00 +0300 +0300" itemprop=datePublished>Jun 23nd 2022</time></p></div></li><li><div class=item-thumbnail><a href=https://romange.github.io/blog/preview/2022/01/30/redis-analysis-part-2-simplicity/ class=thumbnail><span style=background-image:url(https://romange.github.io/blog/preview/banners/simple.jpg) alt="Redis Analysis - Part 2: Simplicity " class=thumbnail-image></span></a></div><div class=item-inner><p class=item-title><a href=https://romange.github.io/blog/preview/2022/01/30/redis-analysis-part-2-simplicity/ class=title>Redis Analysis - Part 2: Simplicity</a></p><p class=item-date><time datetime="2022-01-30 20:00:00 +0200 +0200" itemprop=datePublished>Jan 30nd 2022</time></p></div></li><li><div class=item-thumbnail><a href=https://romange.github.io/blog/preview/2021/12/09/redis-analysis-part-1-threading-model/ class=thumbnail><span style=background-image:url(https://romange.github.io/blog/preview/banners/jet.jpg) alt="Redis Analysis - Part 2: Simplicity " class=thumbnail-image></span></a></div><div class=item-inner><p class=item-title><a href=https://romange.github.io/blog/preview/2021/12/09/redis-analysis-part-1-threading-model/ class=title>Redis Analysis - Part 1: Threading model</a></p><p class=item-date><time datetime="2021-12-09 11:00:00 +0300 +0300" itemprop=datePublished>Dec 9nd 2021</time></p></div></li><li><div class=item-thumbnail><a href=https://romange.github.io/blog/preview/2021/11/28/a-prelude-to-analysis-of-redis-memory-store/ class=thumbnail><span style=background-image:url(https://romange.github.io/blog/preview/banners/1200px-Redis_Logo.svg.png) alt="Redis Analysis - Part 2: Simplicity " class=thumbnail-image></span></a></div><div class=item-inner><p class=item-title><a href=https://romange.github.io/blog/preview/2021/11/28/a-prelude-to-analysis-of-redis-memory-store/ class=title>A prelude to analysis of Redis memory-store</a></p><p class=item-date><time datetime="2021-11-28 17:46:19 +0300 +0300" itemprop=datePublished>Nov 28nd 2021</time></p></div></li></ul></div></div><div class=widget-wrap><h3 class=widget-title>Tags</h3><div class=widget><ul class=category-list><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/asynchronous>asynchronous</a>
<span class=category-list-count>2</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/backend>backend</a>
<span class=category-list-count>2</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/blogging>blogging</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/c++>c++</a>
<span class=category-list-count>8</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/code-generation>code-generation</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/concurrency>concurrency</a>
<span class=category-list-count>2</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/dragonfly>dragonfly</a>
<span class=category-list-count>2</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/fibers>fibers</a>
<span class=category-list-count>2</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/gaia>gaia</a>
<span class=category-list-count>3</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/io_uring>io_uring</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/linux>linux</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/mapreduce>mapreduce</a>
<span class=category-list-count>3</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/posix>posix</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/programming>programming</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/reactive>reactive</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/redis>redis</a>
<span class=category-list-count>5</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/seastar>seastar</a>
<span class=category-list-count>1</span></li></ul></div></div><div class=widget-wrap><h3 class=widget-title>Tag cloud</h3><div class="widget tagcloud"><a href=https://romange.github.io/blog/preview/tags/asynchronous style=font-size:12px>asynchronous</a>
<a href=https://romange.github.io/blog/preview/tags/backend style=font-size:12px>backend</a>
<a href=https://romange.github.io/blog/preview/tags/blogging style=font-size:12px>blogging</a>
<a href=https://romange.github.io/blog/preview/tags/c++ style=font-size:12px>c++</a>
<a href=https://romange.github.io/blog/preview/tags/code-generation style=font-size:12px>code-generation</a>
<a href=https://romange.github.io/blog/preview/tags/concurrency style=font-size:12px>concurrency</a>
<a href=https://romange.github.io/blog/preview/tags/dragonfly style=font-size:12px>dragonfly</a>
<a href=https://romange.github.io/blog/preview/tags/fibers style=font-size:12px>fibers</a>
<a href=https://romange.github.io/blog/preview/tags/gaia style=font-size:12px>gaia</a>
<a href=https://romange.github.io/blog/preview/tags/io_uring style=font-size:12px>io_uring</a>
<a href=https://romange.github.io/blog/preview/tags/linux style=font-size:12px>linux</a>
<a href=https://romange.github.io/blog/preview/tags/mapreduce style=font-size:12px>mapreduce</a>
<a href=https://romange.github.io/blog/preview/tags/posix style=font-size:12px>posix</a>
<a href=https://romange.github.io/blog/preview/tags/programming style=font-size:12px>programming</a>
<a href=https://romange.github.io/blog/preview/tags/reactive style=font-size:12px>reactive</a>
<a href=https://romange.github.io/blog/preview/tags/redis style=font-size:12px>redis</a>
<a href=https://romange.github.io/blog/preview/tags/seastar style=font-size:12px>seastar</a></div></div><div id=toTop class="fa fa-angle-up"></div></aside></div></div><footer id=footer><div class=outer><div id=footer-info class=inner>&copy; 2022
Roman Gershman</div></div></footer><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-107146718-1","auto"),ga("send","pageview"))</script><script src=https://romange.github.io/blog/preview/fancybox/jquery.fancybox.pack.js></script>
<script src=https://romange.github.io/blog/preview/js/script.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js></script>
<script>hljs.initHighlightingOnLoad()</script><script type=text/x-mathjax-config>
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>