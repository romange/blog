<!doctype html><html lang=en-us><head><title>Reloading data structures under high throughput &#183; Это неправильные пчелы</title><meta name=generator content="Hugo 0.85.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=author content="Roman Gershman"><meta name=description content="The wrong sort of bees"><link rel=canonical href=https://www.romange.com/2017/09/29/reloading-data-structures-under-high-throughput/><link rel=icon href=https://www.romange.com/favicon.ico><link rel=apple-touch-icon href=https://www.romange.com/apple-touch-icon.png><link rel=stylesheet href=https://www.romange.com/css/style.css><link rel=stylesheet href=https://www.romange.com/css/font-awesome.min.css><link rel=stylesheet href=https://www.romange.com/css/monokai.css><link rel=stylesheet href=https://www.romange.com/fancybox/jquery.fancybox.css><link href="https://fonts.googleapis.com/css?family=Open+Sans:400italic,400,600" rel=stylesheet type=text/css><link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel=stylesheet type=text/css><meta property="og:title" content="Reloading data structures under high throughput"><meta property="og:description" content="Suppose you have a multi-threaded server that serves tens of thousands read queries per second. Those queries use a shared data-structure or index that is mostly immutable during the server run with the exception of periodic index reloads.  How do you implement data reloads in that server while keeping it live and kicking in production?"><meta property="og:type" content="article"><meta property="og:url" content="https://www.romange.com/2017/09/29/reloading-data-structures-under-high-throughput/"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-09-29T15:46:55+03:00"><meta property="article:modified_time" content="2017-09-29T15:46:55+03:00"><meta itemprop=name content="Reloading data structures under high throughput"><meta itemprop=description content="Suppose you have a multi-threaded server that serves tens of thousands read queries per second. Those queries use a shared data-structure or index that is mostly immutable during the server run with the exception of periodic index reloads.  How do you implement data reloads in that server while keeping it live and kicking in production?"><meta itemprop=datePublished content="2017-09-29T15:46:55+03:00"><meta itemprop=dateModified content="2017-09-29T15:46:55+03:00"><meta itemprop=wordCount content="1213"><meta itemprop=keywords content="c++,concurrency,backend,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Reloading data structures under high throughput"><meta name=twitter:description content="Suppose you have a multi-threaded server that serves tens of thousands read queries per second. Those queries use a shared data-structure or index that is mostly immutable during the server run with the exception of periodic index reloads.  How do you implement data reloads in that server while keeping it live and kicking in production?"><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js></script></head><body><div class=container><div id=container><header id=header><div id=header-main class=header-inner><div class=outer><a href=https://www.romange.com/ id=logo><i class=logo style=background-image:url(https://www.romange.com/css/images/7.png)></i>
<span class=site-title>Это неправильные пчелы</span></a><nav id=main-nav><a class=main-nav-link href=https://www.romange.com/tags/>Tags</a>
<a class=main-nav-link href=https://www.romange.com/about/>About</a></nav><nav id=sub-nav><div class=profile id=profile-nav><a id=profile-anchor href=javascript:;><img class=avatar src=https://www.romange.com/css/images/avatar.png><i class="fa fa-caret-down"></i></a></div></nav><div id=search-form-wrap><form action=//google.com/search method=get accept-charset=utf-8 class=search-form><input type=search name=q class=search-form-input placeholder=Search>
<button type=submit class=search-form-submit></button>
<input type=hidden name=sitesearch value=https://www.romange.com/></form></div></div></div><div id=main-nav-mobile class="header-sub header-inner"><table class="menu outer"><tbody><tr><td><a class=main-nav-link href=https://www.romange.com/tags/>Tags</a></td><td><a class=main-nav-link href=https://www.romange.com/about/>About</a></td><td><form action=//google.com/search method=get accept-charset=utf-8 class=search-form><input type=search name=q class=search-form-input placeholder=Search>
<input type=hidden name=sitesearch value=https://www.romange.com/></form></td></tr></tbody></table></div></header><div class=outer><aside id=profile><div class="inner profile-inner"><div class="base-info profile-block"><img id=avatar src="https://www.gravatar.com/avatar/4a203a48eb1cdb1b8c47d008f0c139c9?s=100&d=identicon"><h2 id=name>Roman Gershman</h2><h3 id=title>Programmer</h3><span id=location><i class="fa fa-map-marker"></i>Tel Aviv</span>
<a id=follow href=https://github.com/romange>Follow</a></div><div class="article-info profile-block"><div class=article-info-block>9
<span>Posts</span></div><div class=article-info-block>14
<span>Tags</span></div></div><div class="profile-block social-links"><table><tr><td><a href=//github.com/romange target=_blank title=GitHub><i class="fa fa-github"></i></a></td><td><a href=//linkedin.com/in/romange target=_blank title=LinkedIn><i class="fa fa-linkedin"></i></a></td><td><a href=//stackoverflow.com/users/romange target=_blank title="Stack Overflow"><i class="fa fa-stack-overflow"></i></a></td><td><a href=https://www.romange.com/index.xml target=_blank title=RSS><i class="fa fa-rss"></i></a></td></tr></table></div></div></aside><section id=main><article id=page-undefined class="article article-type-page" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><a href=https://www.romange.com/2017/09/29/reloading-data-structures-under-high-throughput/><h1 class=article-title itemprop=name>Reloading data structures under high throughput</h1></a><div class=article-meta><div class=article-date><i class="fa fa-calendar"></i>
<time datetime="2017-09-29 15:46:55 +0300 +0300" itemprop=datePublished>Sep 29nd 2017</time>
&#183;
1213
words
&#183;
6
minute read</div><div class=article-category><i class="fa fa-tags"></i>
<a class=article-category-link href=https://www.romange.com/tags/c++>c++</a>
&#183;
<a class=article-category-link href=https://www.romange.com/tags/concurrency>concurrency</a>
&#183;
<a class=article-category-link href=https://www.romange.com/tags/backend>backend</a></div></div></header><div class=article-entry itemprop=articleBody><p>Suppose you have a multi-threaded server that serves tens of thousands read queries per second. Those queries use a shared data-structure or index that is mostly immutable during the server run with the exception of periodic index reloads. How do you implement data reloads in that server while keeping it live and kicking in production?</p><p>Obviously, if your data structure is thread-safe and allows mutations while correctly serving reads
then the problem solved. However, it often happens that either the data structure is not thread-safe or its safety guarantees do now allow seamless reads during relatively slow reloads.</p><p>Lets examine possible solutions to this problem:</p><h3 id=shared-mutex>Shared mutex</h3><p>First, we can not use exclusive mutex to lock the index due to possibly huge contention in the read path: each query thread will require read access to our index and with the exclusive mutex it will stall all other threads until it finishes reading from the index.
<code>shared_mutex</code> will solve this problem, however the reload operation will still need to lock the index exclusively (see below). During that period the read path will be blocked and we came back to the original problem - having stalled reads during reloads.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>
<span style=color:#75715e>// Query Thread
</span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>shared_lock<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>shared_mutex<span style=color:#f92672>&gt;</span> lock(mutex_);   <span style=color:#75715e>// will block on Reload!
</span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> res <span style=color:#f92672>=</span> index_.Query(arg);

.....................

<span style=color:#75715e>// Reload thread.
</span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>unique_lock<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>shared_mutex<span style=color:#f92672>&gt;</span> lock(mutex_);
index.UpdateFromFile(file_name);

</code></pre></div><h3 id=managing-a-pointer-to-immutable-index>managing a pointer to immutable index.</h3><p>If we allow eventual consistency and our memory capacity can hold 2 indices at the same time we can solve the problem by adding a level of indirection: instead of changing the data structure, we will swap a pointer to our always immutable index.
The naive solution could looks like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>
std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span>Index<span style=color:#f92672>*&gt;</span> index_ptr_;

<span style=color:#75715e>// Query Thread
</span><span style=color:#75715e></span>Index<span style=color:#f92672>*</span> index <span style=color:#f92672>=</span> index_ptr_<span style=color:#f92672>-&gt;</span>load();
<span style=color:#66d9ef>auto</span> res <span style=color:#f92672>=</span> index<span style=color:#f92672>-&gt;</span>Query(arg);   <span style=color:#75715e>// index can be invalid here.
</span><span style=color:#75715e></span>................

<span style=color:#75715e>// Reload thread.
</span><span style=color:#75715e></span>Index<span style=color:#f92672>*</span> new_index <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Index(); <span style=color:#75715e>// At this point we have 2 indices in RAM
</span><span style=color:#75715e></span>new_index<span style=color:#f92672>-&gt;</span>UpdateFromFile(file_name);

new_index <span style=color:#f92672>=</span> atomic_exchange(<span style=color:#f92672>&amp;</span>index_ptr_, new_index);  <span style=color:#75715e>// Swap the pointers.
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>delete</span> new_index;   <span style=color:#75715e>// delete the previous index object.
</span></code></pre></div><p>The problem with this solution, of course, is the dangling pointer during the read path.
When the ownership over the pointer is managed by reload thread, we can not know when the read threads finish accessing it and it can be safely deleted. This is a classic example where shared_ptr will come to rescue:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>
shared_ptr<span style=color:#f92672>&lt;</span>Index<span style=color:#f92672>&gt;</span> index_ptr_;

<span style=color:#75715e>// Query Thread
</span><span style=color:#75715e></span>shared_ptr<span style=color:#f92672>&lt;</span>Index<span style=color:#f92672>&gt;</span> local_copy <span style=color:#f92672>=</span> atomic_load(<span style=color:#f92672>&amp;</span>index_ptr_);
<span style=color:#66d9ef>auto</span> res <span style=color:#f92672>=</span> local_copy<span style=color:#f92672>-&gt;</span>Query(arg);
...................

<span style=color:#75715e>// Reload thread.
</span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>Index<span style=color:#f92672>&gt;</span> new_index <span style=color:#f92672>=</span> make_shared<span style=color:#f92672>&lt;</span>Index<span style=color:#f92672>&gt;</span>(); <span style=color:#75715e>// Create another index object.
</span><span style=color:#75715e></span>new_index<span style=color:#f92672>-&gt;</span>UpdateFromFile(file_name);

<span style=color:#66d9ef>auto</span> prev <span style=color:#f92672>=</span> atomic_exchange(<span style=color:#f92672>&amp;</span>index_ptr_, new_index);  <span style=color:#75715e>// Swap the pointers.
</span><span style=color:#75715e></span>prev.reset();  <span style=color:#75715e>// or just goes out of scope. In any case we reduce reference count
</span><span style=color:#75715e></span>               <span style=color:#75715e>// to the old Index.
</span></code></pre></div><p>shared_ptr provides built-in atomicity guarantees when incrementing/decrementing its reference count but not when the contents of shared_ptr are fully replaced with the new object instance.
Therefore we must use special functions <code>atomic_exchange</code> and <code>atomic_load</code> that provide atomicity guarantees for whole shared_ptr object. In other words we must use the atomic transaction when swapping shared_ptr. <code>atomic_load</code> is just for synchronizing the read with this transaction.</p><p>Unfortunately the approach above has 2 problems:</p><ol><li>gcc 4.8 does not support <code>atomic_exchange</code> for shared_ptr. Even though the code builds it won&rsquo;t be atomic.</li><li>In versions where <code>atomic_exchange</code> is implemented for shared_ptr it&rsquo;s usually done with a global lock shared by potentially several instances of shared_ptr. In other words <code>atomic_exchange</code>has suboptimal performance.</li></ol><p>Experimental library of C++ has <code>std::experimental::atomic_shared_ptr</code> which is designed to overcome the latter issue but it&rsquo;s not in the standard yet. So for now I suggest to use a shared lock which can protect shared_ptr. It might be better to use a cheap spinlock here because we just need to provide atomicity for writing into few memory cells.</p><p>I suggest to use an excellent <a href=https://github.com/facebook/folly/blob/master/folly/RWSpinLock.h>Folly&rsquo;s RWSpinLock</a>. Lately they added <a href=https://github.com/facebook/folly/blob/master/folly/SharedMutex.h>SharedMutex</a> lock but I&rsquo;ve not tried it yet.
So the final version (with RWSpinLock) might look like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>RWSpinLock index_lock_;
shared_ptr<span style=color:#f92672>&lt;</span>Index<span style=color:#f92672>&gt;</span> index_ptr_;

<span style=color:#75715e>// Query Thread
</span><span style=color:#75715e></span>index_lock_.lock_shared();
shared_ptr<span style=color:#f92672>&lt;</span>Index<span style=color:#f92672>&gt;</span> local_copy <span style=color:#f92672>=</span> index_ptr_;
index_lock_.unlock_shared();

<span style=color:#66d9ef>auto</span> res <span style=color:#f92672>=</span> local_copy<span style=color:#f92672>-&gt;</span>Query(arg);
..................

<span style=color:#75715e>// Reload thread.
</span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>Index<span style=color:#f92672>&gt;</span> new_index <span style=color:#f92672>=</span> make_shared<span style=color:#f92672>&lt;</span>Index<span style=color:#f92672>&gt;</span>(); <span style=color:#75715e>// Create another index object.
</span><span style=color:#75715e></span>new_index<span style=color:#f92672>-&gt;</span>UpdateFromFile(file_name);

index_lock_.lock();
index_ptr_.swap(new_index);
index_lock_.unlock();

new_index.reset();  <span style=color:#75715e>// or just goes out of scope. In any case we reduce reference count
</span><span style=color:#75715e></span>                    <span style=color:#75715e>// to the old Index.
</span></code></pre></div><p>Please note that it&rsquo;s important to limit locked sections only to pointer changes. Anything else should be outside of lock to reduce the contention. This is why I do not use lock guards in the section above - I want to mark locking explicitly in most straighforward manner. I&rsquo;ve seen lots of cases where lock guards were used and it caused huge contention after very innocent code changes were applied later.</p><p>It is guaranteed that the read thread protects the lifespan of the index via the local_copy object it holds and it&rsquo;s enough to use shared lock when creating <code>local_copy</code> because we do not change the internal contents of <code>index_ptr_</code> - just increase the reference count which is atomic.</p><h3 id=quiescent-state-based-reclamation>Quiescent State-Based Reclamation</h3><p>Jeff Preshing in his <a href=http://preshing.com/20160726/using-quiescent-states-to-reclaim-memory/>blog post</a> tackles similar problem but he solves resource deletion issue by using GC method called <em>quiescent state-based reclamation</em> (QSBR). Yeah, I needed to look up word <em>quiescent</em> in the dictionary as well. It means &ldquo;in state of inactivity or dormancy&rdquo;. Basically QSBR postpones resource deletion to a time when all the possible threads finished their tasks. Then nothing references the stale resource and it&rsquo;s safe to delete it.</p><p>QSBR requires thread cooperation at framework level, i.e. each thread needs to register itself with QSBR manager, and notify it every time it runs a task or finishes it. This way QSBR manager can know when the process has quiescent states and no user-level tasks are running. During this state it runs all the piled deletion callbacks from the last period. The sketch code with this solution will look similar to our first naive version:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>
std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span>Index<span style=color:#f92672>*&gt;</span> index_ptr_;

<span style=color:#75715e>// Query Thread
</span><span style=color:#75715e>// Called by framework:
</span><span style=color:#75715e></span>QSBR()<span style=color:#f92672>-&gt;</span>StartTask();
<span style=color:#75715e>///
</span><span style=color:#75715e></span>
<span style=color:#75715e>// This load can return either new instance or the old one. Both are fine.
</span><span style=color:#75715e></span>Index<span style=color:#f92672>*</span> index <span style=color:#f92672>=</span> index_ptr_<span style=color:#f92672>-&gt;</span>load();
<span style=color:#66d9ef>auto</span> res <span style=color:#f92672>=</span> index<span style=color:#f92672>-&gt;</span>Query(arg);
...
<span style=color:#75715e>// Called by framework:
</span><span style=color:#75715e></span>QSBR()<span style=color:#f92672>-&gt;</span>EndTask();   <span style=color:#75715e>// marks end of user-level task for this thread.
</span><span style=color:#75715e></span>.....

<span style=color:#75715e>///////////////////////////////////////
</span><span style=color:#75715e>// Reload thread.
</span><span style=color:#75715e></span>Index<span style=color:#f92672>*</span> new_index <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Index(); <span style=color:#75715e>// At this point we have 2 indices in RAM
</span><span style=color:#75715e></span>new_index<span style=color:#f92672>-&gt;</span>UpdateFromFile(file_name);

new_index <span style=color:#f92672>=</span> atomic_exchange(<span style=color:#f92672>&amp;</span>index_ptr_, new_index);  <span style=color:#75715e>// Swap the pointers.
</span><span style=color:#75715e></span>
<span style=color:#75715e>// Schedules the previous instance for deletion.
</span><span style=color:#75715e>// This is the main change. We do not delete the index now but ask to run it
</span><span style=color:#75715e>// when it&#39;s safe.
</span><span style=color:#75715e></span>QSBR()<span style=color:#f92672>-&gt;</span>Schedule([new_index] { <span style=color:#66d9ef>delete</span> new_index;});
</code></pre></div><p>The advantage of this approach is that we do not need to worry about ownership issues. Once we build the solution at the framework level it will always help us with freewing resources asynchronously in a safe manner. Another advantage is that it&rsquo;s faster. We do not need to lock anything per resource, instead the framework provides unified lockless approach for similar problems.</p><p>In Jeff&rsquo;s example his QSBR implementation breaks timeline into discrete intervals. All the threads that run tasks during specific interval register themselves before running user-level tasks and unregister afterwards. Once all the threads have been unregistered for a interval, it can be <code>cleaned</code> by running its pending GC callbacks.</p><p>I do not know any other methods for providing responsive reads during data reloads. If you know any - please write in comments.</p></div><footer class=article-footer><a data-url=https://www.romange.com/2017/09/29/reloading-data-structures-under-high-throughput/ data-id=88f7f46386a436887c0e105d375a6913 class=article-share-link><i class="fa fa-share"></i>
Share</a>
<a href=https://www.romange.com/2017/09/29/reloading-data-structures-under-high-throughput/#disqus_thread class=article-comment-link>Comments</a>
<script>(function(a){if(typeof __SHARE_BUTTON_BINDED__=='undefined'||!__SHARE_BUTTON_BINDED__)__SHARE_BUTTON_BINDED__=!0;else return;a('body').on('click',function(){a('.article-share-box.on').removeClass('on')}).on('click','.article-share-link',function(i){var d,f,c,e,g,b,h;if(i.stopPropagation(),d=a(this),f=d.attr('data-url'),c=encodeURIComponent(f),e='article-share-box-'+d.attr('data-id'),g=d.offset(),a('#'+e).length){if(b=a('#'+e),b.hasClass('on')){b.removeClass('on');return}}else h=['<div id="'+e+'" class="article-share-box">','<input class="article-share-input" value="'+f+'">','<div class="article-share-links">','<a href="https://twitter.com/intent/tweet?url='+c+'" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>','<a href="https://www.facebook.com/sharer.php?u='+c+'" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>','<a href="http://pinterest.com/pin/create/button/?url='+c+'" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>','<a href="https://plus.google.com/share?url='+c+'" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>','</div>','</div>'].join(''),b=a(h),a('body').append(b);a('.article-share-box.on').hide(),b.css({top:g.top+25,left:g.left}).addClass('on')}).on('click','.article-share-box',function(a){a.stopPropagation()}).on('click','.article-share-box-input',function(){a(this).select()}).on('click','.article-share-box-link',function(a){a.preventDefault(),a.stopPropagation(),window.open(this.href,'article-share-box-window-'+Date.now(),'width=500,height=450')})})(jQuery)</script></footer></div><nav id=article-nav><a href=https://www.romange.com/2017/09/26/how-to-serialize-integers-into-memory/ id=article-nav-older class=article-nav-link-wrap><strong class=article-nav-caption>Older</strong><div class=article-nav-title>How to serialize integers into memory</div></a><a href=https://www.romange.com/2017/11/02/implementing-cheap-and-precise-clock/ id=article-nav-newer class=article-nav-link-wrap><strong class=article-nav-caption>Newer</strong><div class=article-nav-title>Implementing cheap and precise clock</div></a></nav></article><section id=comments><div id=disqus_thread><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//romange.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></section></section><aside id=sidebar><div class=widget-wrap><h3 class=widget-title>Recents</h3><div class=widget><ul id=recent-post><li><div class=item-thumbnail><a href=https://www.romange.com/2019/11/01/gaia-mapreduce-tutorial-part2/ class=thumbnail><span class="thumbnail-image thumbnail-none"></span></a></div><div class=item-inner><p class=item-title><a href=https://www.romange.com/2019/11/01/gaia-mapreduce-tutorial-part2/ class=title>Gaia Mapreduce Tutorial - part2</a></p><p class=item-date><time datetime="2019-11-01 10:30:12 +0300 +0300" itemprop=datePublished>Nov 1nd 2019</time></p></div></li><li><div class=item-thumbnail><a href=https://www.romange.com/2019/07/25/benchmarking-gaia-mr-on-google-cloud/ class=thumbnail><span class="thumbnail-image thumbnail-none"></span></a></div><div class=item-inner><p class=item-title><a href=https://www.romange.com/2019/07/25/benchmarking-gaia-mr-on-google-cloud/ class=title>Benchmarking GAIA MR on Google cloud</a></p><p class=item-date><time datetime="2019-07-25 11:38:01 +0300 +0300" itemprop=datePublished>Jul 25nd 2019</time></p></div></li><li><div class=item-thumbnail><a href=https://www.romange.com/2019/07/15/gaia-mapreduce-tutorial-part1/ class=thumbnail><span class="thumbnail-image thumbnail-none"></span></a></div><div class=item-inner><p class=item-title><a href=https://www.romange.com/2019/07/15/gaia-mapreduce-tutorial-part1/ class=title>Gaia Mapreduce Tutorial - part1</a></p><p class=item-date><time datetime="2019-07-15 00:00:35 +0300 +0300" itemprop=datePublished>Jul 15nd 2019</time></p></div></li><li><div class=item-thumbnail><a href=https://www.romange.com/2018/12/15/introduction-to-fibers-in-c-/ class=thumbnail><span style=background-image:url(https://www.romange.com/banners/fibers.png) alt="Reloading data structures under high throughput" class=thumbnail-image></span></a></div><div class=item-inner><p class=item-title><a href=https://www.romange.com/2018/12/15/introduction-to-fibers-in-c-/ class=title>Introduction to fibers in c++</a></p><p class=item-date><time datetime="2018-12-15 11:59:52 +0300 +0300" itemprop=datePublished>Dec 15nd 2018</time></p></div></li><li><div class=item-thumbnail><a href=https://www.romange.com/2018/07/12/seastar-asynchronous-c-framework/ class=thumbnail><span style=background-image:url(https://www.romange.com/banners/seastar.png) alt="Reloading data structures under high throughput" class=thumbnail-image></span></a></div><div class=item-inner><p class=item-title><a href=https://www.romange.com/2018/07/12/seastar-asynchronous-c-framework/ class=title>Seastar - Asynchronous C++ framework</a></p><p class=item-date><time datetime="2018-07-12 20:45:24 +0300 +0300" itemprop=datePublished>Jul 12nd 2018</time></p></div></li></ul></div></div><div class=widget-wrap><h3 class=widget-title>Tags</h3><div class=widget><ul class=category-list><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/asynchronous>asynchronous</a>
<span class=category-list-count>2</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/backend>backend</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/blogging>blogging</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/c++>c++</a>
<span class=category-list-count>7</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/code-generation>code-generation</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/concurrency>concurrency</a>
<span class=category-list-count>2</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/fibers>fibers</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/gaia>gaia</a>
<span class=category-list-count>3</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/linux>linux</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/mapreduce>mapreduce</a>
<span class=category-list-count>3</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/posix>posix</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/programming>programming</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/reactive>reactive</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/seastar>seastar</a>
<span class=category-list-count>1</span></li></ul></div></div><div class=widget-wrap><h3 class=widget-title>Tag cloud</h3><div class="widget tagcloud"><a href=https://www.romange.com/tags/asynchronous style=font-size:12px>asynchronous</a>
<a href=https://www.romange.com/tags/backend style=font-size:12px>backend</a>
<a href=https://www.romange.com/tags/blogging style=font-size:12px>blogging</a>
<a href=https://www.romange.com/tags/c++ style=font-size:12px>c++</a>
<a href=https://www.romange.com/tags/code-generation style=font-size:12px>code-generation</a>
<a href=https://www.romange.com/tags/concurrency style=font-size:12px>concurrency</a>
<a href=https://www.romange.com/tags/fibers style=font-size:12px>fibers</a>
<a href=https://www.romange.com/tags/gaia style=font-size:12px>gaia</a>
<a href=https://www.romange.com/tags/linux style=font-size:12px>linux</a>
<a href=https://www.romange.com/tags/mapreduce style=font-size:12px>mapreduce</a>
<a href=https://www.romange.com/tags/posix style=font-size:12px>posix</a>
<a href=https://www.romange.com/tags/programming style=font-size:12px>programming</a>
<a href=https://www.romange.com/tags/reactive style=font-size:12px>reactive</a>
<a href=https://www.romange.com/tags/seastar style=font-size:12px>seastar</a></div></div><div id=toTop class="fa fa-angle-up"></div></aside></div></div><footer id=footer><div class=outer><div id=footer-info class=inner>&copy; 2021
Roman Gershman</div></div></footer><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-107146718-1','auto'),ga('send','pageview'))</script><script src=https://www.romange.com/fancybox/jquery.fancybox.pack.js></script><script src=https://www.romange.com/js/script.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script></body></html>