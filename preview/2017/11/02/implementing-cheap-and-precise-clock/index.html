<!doctype html><html lang=en-us><head><title>Implementing cheap and precise clock &#183; These are the wrong sort of bees</title><meta name=generator content="Hugo 0.104.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=author content="Roman Gershman"><meta name=description content="The wrong sort of bees"><link rel=canonical href=https://romange.github.io/blog/preview/2017/11/02/implementing-cheap-and-precise-clock/><link rel=icon href=https://romange.github.io/blog/preview/favicon.ico><link rel=apple-touch-icon href=https://romange.github.io/blog/preview/apple-touch-icon.png><link rel=stylesheet href=https://romange.github.io/blog/preview/css/style.css><link rel=stylesheet href=https://romange.github.io/blog/preview/css/font-awesome.min.css><link rel=stylesheet href=https://romange.github.io/blog/preview/css/monokai.css><link rel=stylesheet href=https://romange.github.io/blog/preview/fancybox/jquery.fancybox.css><link href='https://fonts.googleapis.com/css?family=Open+Sans:400italic,400,600' rel=stylesheet type=text/css><link href='https://fonts.googleapis.com/css?family=Source+Code+Pro' rel=stylesheet type=text/css><meta property="og:title" content="Implementing cheap and precise clock"><meta property="og:description" content="The posix API for querying high-precision hardware clocks is clock_gettime. If one second precision is fine then time(nullptr) is your friend. Unfortunately, using precice clocks takes its price - they are more expensive CPU-wise."><meta property="og:type" content="article"><meta property="og:url" content="https://romange.github.io/blog/preview/2017/11/02/implementing-cheap-and-precise-clock/"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-11-02T13:37:51+02:00"><meta property="article:modified_time" content="2017-11-02T13:37:51+02:00"><meta itemprop=name content="Implementing cheap and precise clock"><meta itemprop=description content="The posix API for querying high-precision hardware clocks is clock_gettime. If one second precision is fine then time(nullptr) is your friend. Unfortunately, using precice clocks takes its price - they are more expensive CPU-wise."><meta itemprop=datePublished content="2017-11-02T13:37:51+02:00"><meta itemprop=dateModified content="2017-11-02T13:37:51+02:00"><meta itemprop=wordCount content="649"><meta itemprop=keywords content="c++,linux,posix,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementing cheap and precise clock"><meta name=twitter:description content="The posix API for querying high-precision hardware clocks is clock_gettime. If one second precision is fine then time(nullptr) is your friend. Unfortunately, using precice clocks takes its price - they are more expensive CPU-wise."><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js></script></head><body><div class=container><div id=container><header id=header><div id=header-main class=header-inner><div class=outer><a href=https://romange.github.io/blog/preview/ id=logo><i class=logo style=background-image:url(https://romange.github.io/blog/preview/css/images/7.png)></i>
<span class=site-title>These are the wrong sort of bees</span></a><nav id=main-nav><a class=main-nav-link href=https://romange.github.io/blog/preview/tags/>Tags</a>
<a class=main-nav-link href=https://romange.github.io/blog/preview/about/>About</a></nav><nav id=sub-nav><div class=profile id=profile-nav><a id=profile-anchor href=javascript:;><img class=avatar src=https://romange.github.io/blog/preview/css/images/avatar.png><i class="fa fa-caret-down"></i></a></div></nav><div id=search-form-wrap><form action=//google.com/search method=get accept-charset=utf-8 class=search-form><input type=search name=q class=search-form-input placeholder=Search>
<button type=submit class=search-form-submit></button>
<input type=hidden name=sitesearch value=https://romange.github.io/blog/preview/></form></div></div></div><div id=main-nav-mobile class="header-sub header-inner"><table class="menu outer"><tbody><tr><td><a class=main-nav-link href=https://romange.github.io/blog/preview/tags/>Tags</a></td><td><a class=main-nav-link href=https://romange.github.io/blog/preview/about/>About</a></td><td><form action=//google.com/search method=get accept-charset=utf-8 class=search-form><input type=search name=q class=search-form-input placeholder=Search>
<input type=hidden name=sitesearch value=https://romange.github.io/blog/preview/></form></td></tr></tbody></table></div></header><div class=outer><aside id=profile><div class="inner profile-inner"><div class="base-info profile-block"><img id=avatar src="https://www.gravatar.com/avatar/4a203a48eb1cdb1b8c47d008f0c139c9?s=100&d=identicon"><h2 id=name>Roman Gershman</h2><h3 id=title>Software Engineer</h3><span id=location><i class="fa fa-map-marker"></i>Tel Aviv</span>
<a id=follow href=https://github.com/romange>Follow</a></div><div class="article-info profile-block"><div class=article-info-block>14
<span>Posts</span></div><div class=article-info-block>17
<span>Tags</span></div></div><div class="profile-block social-links"><table><tr><td><a href=//github.com/romange target=_blank title=GitHub><i class="fa fa-github"></i></a></td><td><a href=//linkedin.com/in/romange target=_blank title=LinkedIn><i class="fa fa-linkedin"></i></a></td><td><a href=//stackoverflow.com/users/romange target=_blank title="Stack Overflow"><i class="fa fa-stack-overflow"></i></a></td><td><a href=https://romange.github.io/blog/preview/index.xml target=_blank title=RSS><i class="fa fa-rss"></i></a></td></tr></table></div></div></aside><section id=main><article id=page-undefined class="article article-type-page" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><a href=https://romange.github.io/blog/preview/2017/11/02/implementing-cheap-and-precise-clock/><h1 class=article-title itemprop=name>Implementing cheap and precise clock</h1></a><div class=article-meta><div class=article-date><i class="fa fa-calendar"></i>
<time datetime="2017-11-02 13:37:51 +0200 +0200" itemprop=datePublished>Nov 2nd 2017</time>
&#183;
649
words
&#183;
4
minute read</div><div class=article-category><i class="fa fa-tags"></i>
<a class=article-category-link href=https://romange.github.io/blog/preview/tags/c++>c++</a>
&#183;
<a class=article-category-link href=https://romange.github.io/blog/preview/tags/linux>linux</a>
&#183;
<a class=article-category-link href=https://romange.github.io/blog/preview/tags/posix>posix</a></div></div></header><div class=article-entry itemprop=articleBody><p>The posix API for querying high-precision hardware clocks is <code>clock_gettime</code>. If one second precision is fine then <code>time(nullptr)</code> is your friend. Unfortunately, using precice clocks takes its price - they are more expensive CPU-wise.</p><p>How expensive? On my machine precise versions like <code>CLOCK_MONOTONIC</code> and <code>CLOCK_REALTIME</code> are 9 times more expensive than <code>time(nullptr)</code> and 4 times more expensive than their <code>COARSE</code> counterparts. <code>COARSE</code> clocks are probably enough as long as you do not need precision better than 10ms.</p><p>For a high throughput process that requires sub-ms precision and might call <code>clock_gettime</code> hundreds of thousands times per second (for measuring the latency of its incoming requests for example), this function can appear high on CPU profiler radar. Below I provide a solution for a very cheap clock with precision of 0.1ms.</p><p>The idea is to cache the clock value inside a process variable and to update it with the required precision. The goal is to make update thread as light as possible and very precise.
The simple solution will be (I omit checking error states for brevity):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>static</span> std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int64_t</span><span style=color:#f92672>&gt;</span> timer_count_micros;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>uint32_t</span> kNumMicrosPerSecond <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000000</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>SleepMicros</span>(<span style=color:#66d9ef>uint32_t</span> micros) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>timespec</span> sleep_time;
</span></span><span style=display:flex><span>  sleep_time.tv_sec <span style=color:#f92672>=</span> micros <span style=color:#f92672>/</span> kNumMicrosPerSecond;
</span></span><span style=display:flex><span>  sleep_time.tv_nsec <span style=color:#f92672>=</span> (micros <span style=color:#f92672>%</span> kNumMicrosPerSecond) <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// To protect against signals.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>while</span> (nanosleep(<span style=color:#f92672>&amp;</span>sleep_time, <span style=color:#f92672>&amp;</span>sleep_time) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> errno <span style=color:#f92672>==</span> EINTR) {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>UpdateTimerCounter</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> arg) {
</span></span><span style=display:flex><span>  timespec ts;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int64_t</span> sleep_micros <span style=color:#f92672>=</span> <span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int64_t</span><span style=color:#f92672>&gt;</span>(arg);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (IsEnabled()) {
</span></span><span style=display:flex><span>    clock_gettime(CLOCK_REALTIME, <span style=color:#f92672>&amp;</span>ts);
</span></span><span style=display:flex><span>    timer_count_micros.store(ts.tv_sec <span style=color:#f92672>*</span> kNumMicrosPerSecond <span style=color:#f92672>+</span> ts.tv_nsec <span style=color:#f92672>/</span> <span style=color:#ae81ff>1000</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SleepMicros(sleep_micros);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pthread_t <span style=color:#a6e22e>InitCacheClock</span>(<span style=color:#66d9ef>uint32_t</span> precision_micros) {
</span></span><span style=display:flex><span>  pthread_t result;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  timespec ts;
</span></span><span style=display:flex><span>  clock_gettime(CLOCK_REALTIME, <span style=color:#f92672>&amp;</span>ts);
</span></span><span style=display:flex><span>  timer_count_micros.store(ts.tv_sec <span style=color:#f92672>*</span> kNumMicrosPerSecond <span style=color:#f92672>+</span> ts.tv_nsec <span style=color:#f92672>/</span> <span style=color:#ae81ff>1000</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  pthread_create(<span style=color:#f92672>&amp;</span>result, <span style=color:#66d9ef>nullptr</span>, UpdateTimerCounter,
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>*&gt;</span>(precision_micros <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In short, <code>UpdateMsCounter</code> thread synchronizes our process timer variable with latest clock
value. Then it just sleeps and frees the CPU for other tasks. The CPU cost will be linear to our desired precision: lower <code>precision_micros</code> is - more iterations our thread will perform.</p><p>Unfortunately this implementation has low precision because of the <code>nanosleep</code> function: it does not guarantee that the thread will be awaken exactly after <code>sleep_micros</code>. In fact, it can take few milliseconds or even more until thread scheduler will context switch to our thread. Another minor disadvantage of this approach that we have 2 system calls per iteration which is a bit costly.</p><h3 id=using-timer-file-descriptors>Using timer file descriptors</h3><p>Timer file descriptors (in <code>&lt;sys/timerfd.h></code> are linux-specific timers that allow measuring time via file descriptor interface. The advantage of this approach that we can have a thread that does not sleep but still blocks on read and unblocks with desired precision.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>uint64_t</span> kPrecisionMicros <span style=color:#f92672>=</span> <span style=color:#ae81ff>50</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> std<span style=color:#f92672>::</span>atomic_int timer_fd <span style=color:#f92672>=</span> ATOMIC_VAR_INIT(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>UpdateTimerCounter</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> arg) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> fd;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint64_t</span> missed;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// I use `timer_fd` as both cancel signal and container for timer descriptor.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>while</span> ((fd <span style=color:#f92672>=</span> timer_fd.load(std<span style=color:#f92672>::</span>memory_order_relaxed)) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// `read` blocks according to timer configuration of `fd`.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> read(fd, <span style=color:#f92672>&amp;</span>missed, <span style=color:#66d9ef>sizeof</span> missed);
</span></span><span style=display:flex><span>    DCHECK_EQ(<span style=color:#ae81ff>8</span>, ret); <span style=color:#75715e>// it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    timer_count_micros.fetch_add(missed <span style=color:#f92672>*</span> kPrecisionMicros, std<span style=color:#f92672>::</span>memory_order_release);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pthread_t <span style=color:#a6e22e>InitCacheClock</span>() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* Set up a periodic timer with cycle = kPrecisionMicros */</span>
</span></span><span style=display:flex><span>  timer_fd <span style=color:#f92672>=</span> timerfd_create(CLOCK_REALTIME, TFD_CLOEXEC);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>itimerspec</span> its;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  its.it_value.tv_sec <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  its.it_value.tv_nsec <span style=color:#f92672>=</span> kPrecisionMicros <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Setup periodic timer of the same interval.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  its.it_interval <span style=color:#f92672>=</span> its.it_value;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  timerfd_settime(timer_fd, <span style=color:#ae81ff>0</span> <span style=color:#75715e>/* its is RELATIVE */</span>, <span style=color:#f92672>&amp;</span>its, NULL);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  timespec ts;
</span></span><span style=display:flex><span>  clock_gettime(CLOCK_REALTIME, <span style=color:#f92672>&amp;</span>ts);
</span></span><span style=display:flex><span>  timer_count_micros.store(ts.tv_sec <span style=color:#f92672>*</span> kNumMicrosPerSecond <span style=color:#f92672>+</span> ts.tv_nsec <span style=color:#f92672>/</span> <span style=color:#ae81ff>1000</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  pthread_create(<span style=color:#f92672>&amp;</span>result, <span style=color:#66d9ef>nullptr</span>, UpdateTimerCounter, <span style=color:#66d9ef>nullptr</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Usually <code>missed</code> variable will hold 1 but if a single iteration was delayed than it will contain values larger than 1. Thus the thread loop is self-adjusting to the clock. The thread does not take much CPU (for sane kPrecisionMicros values), uses a single <code>read</code> system call and provides a good alternative for sub-millisecond precision measurements. As I said earlier, the only disadvantage I found with this approach is that it&rsquo;s linux specific.
Please tell me what you think about it or if you thought of better ways to measure clocks.</p></div><footer class=article-footer><a data-url=https://romange.github.io/blog/preview/2017/11/02/implementing-cheap-and-precise-clock/ data-id=c14b7dd2e5be38d68b9cebc2e213a83a class=article-share-link><i class="fa fa-share"></i>
Share</a>
<a href=https://romange.github.io/blog/preview/2017/11/02/implementing-cheap-and-precise-clock/#disqus_thread class=article-comment-link>Comments</a>
<script>(function(e){if(typeof __SHARE_BUTTON_BINDED__=="undefined"||!__SHARE_BUTTON_BINDED__)__SHARE_BUTTON_BINDED__=!0;else return;e("body").on("click",function(){e(".article-share-box.on").removeClass("on")}).on("click",".article-share-link",function(t){t.stopPropagation();var n,c,o=e(this),a=o.attr("data-url"),s=encodeURIComponent(a),i="article-share-box-"+o.attr("data-id"),r=o.offset();if(e("#"+i).length){if(n=e("#"+i),n.hasClass("on")){n.removeClass("on");return}}else c=['<div id="'+i+'" class="article-share-box">','<input class="article-share-input" value="'+a+'">','<div class="article-share-links">','<a href="https://twitter.com/intent/tweet?url='+s+'" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>','<a href="https://www.facebook.com/sharer.php?u='+s+'" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>','<a href="http://pinterest.com/pin/create/button/?url='+s+'" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>','<a href="https://plus.google.com/share?url='+s+'" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',"</div>","</div>"].join(""),n=e(c),e("body").append(n);e(".article-share-box.on").hide(),n.css({top:r.top+25,left:r.left}).addClass("on")}).on("click",".article-share-box",function(e){e.stopPropagation()}).on("click",".article-share-box-input",function(){e(this).select()}).on("click",".article-share-box-link",function(e){e.preventDefault(),e.stopPropagation(),window.open(this.href,"article-share-box-window-"+Date.now(),"width=500,height=450")})})(jQuery)</script></footer></div><nav id=article-nav><a href=https://romange.github.io/blog/preview/2017/09/29/reloading-data-structures-under-high-throughput/ id=article-nav-older class=article-nav-link-wrap><strong class=article-nav-caption>Older</strong><div class=article-nav-title>Reloading data structures under high throughput</div></a><a href=https://romange.github.io/blog/preview/2018/07/12/seastar-asynchronous-c-framework/ id=article-nav-newer class=article-nav-link-wrap><strong class=article-nav-caption>Newer</strong><div class=article-nav-title>Seastar - Asynchronous C++ framework</div></a></nav></article><section id=comments><div id=disqus_thread><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//romange.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></section></section><aside id=sidebar><div class=widget-wrap><h3 class=widget-title>Recents</h3><div class=widget><ul id=recent-post><li><div class=item-thumbnail><a href=https://romange.github.io/blog/preview/2022/06/23/dragonfly-cache-design/ class=thumbnail><span class="thumbnail-image thumbnail-none"></span></a></div><div class=item-inner><p class=item-title><a href=https://romange.github.io/blog/preview/2022/06/23/dragonfly-cache-design/ class=title>Dragonfly Cache Design</a></p><p class=item-date><time datetime="2022-06-23 12:00:00 +0300 +0300" itemprop=datePublished>Jun 23nd 2022</time></p></div></li><li><div class=item-thumbnail><a href=https://romange.github.io/blog/preview/2022/01/30/redis-analysis-part-2-simplicity/ class=thumbnail><span style=background-image:url(https://romange.github.io/blog/preview/banners/simple.jpg) alt="Implementing cheap and precise clock" class=thumbnail-image></span></a></div><div class=item-inner><p class=item-title><a href=https://romange.github.io/blog/preview/2022/01/30/redis-analysis-part-2-simplicity/ class=title>Redis Analysis - Part 2: Simplicity</a></p><p class=item-date><time datetime="2022-01-30 20:00:00 +0200 +0200" itemprop=datePublished>Jan 30nd 2022</time></p></div></li><li><div class=item-thumbnail><a href=https://romange.github.io/blog/preview/2021/12/09/redis-analysis-part-1-threading-model/ class=thumbnail><span style=background-image:url(https://romange.github.io/blog/preview/banners/jet.jpg) alt="Implementing cheap and precise clock" class=thumbnail-image></span></a></div><div class=item-inner><p class=item-title><a href=https://romange.github.io/blog/preview/2021/12/09/redis-analysis-part-1-threading-model/ class=title>Redis Analysis - Part 1: Threading model</a></p><p class=item-date><time datetime="2021-12-09 11:00:00 +0300 +0300" itemprop=datePublished>Dec 9nd 2021</time></p></div></li><li><div class=item-thumbnail><a href=https://romange.github.io/blog/preview/2021/11/28/a-prelude-to-analysis-of-redis-memory-store/ class=thumbnail><span style=background-image:url(https://romange.github.io/blog/preview/banners/1200px-Redis_Logo.svg.png) alt="Implementing cheap and precise clock" class=thumbnail-image></span></a></div><div class=item-inner><p class=item-title><a href=https://romange.github.io/blog/preview/2021/11/28/a-prelude-to-analysis-of-redis-memory-store/ class=title>A prelude to analysis of Redis memory-store</a></p><p class=item-date><time datetime="2021-11-28 17:46:19 +0300 +0300" itemprop=datePublished>Nov 28nd 2021</time></p></div></li><li><div class=item-thumbnail><a href=https://romange.github.io/blog/preview/2020/09/05/io_uring-powered-event-loop-with-efficient-message-passing/ class=thumbnail><span class="thumbnail-image thumbnail-none"></span></a></div><div class=item-inner><p class=item-title><a href=https://romange.github.io/blog/preview/2020/09/05/io_uring-powered-event-loop-with-efficient-message-passing/ class=title>IO_URING powered event-loop with efficient message passing</a></p><p class=item-date><time datetime="2020-09-05 20:30:11 +0300 +0300" itemprop=datePublished>Sep 5nd 2020</time></p></div></li></ul></div></div><div class=widget-wrap><h3 class=widget-title>Tags</h3><div class=widget><ul class=category-list><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/asynchronous>asynchronous</a>
<span class=category-list-count>2</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/backend>backend</a>
<span class=category-list-count>2</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/blogging>blogging</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/c++>c++</a>
<span class=category-list-count>8</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/code-generation>code-generation</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/concurrency>concurrency</a>
<span class=category-list-count>2</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/dragonfly>dragonfly</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/fibers>fibers</a>
<span class=category-list-count>2</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/gaia>gaia</a>
<span class=category-list-count>3</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/io_uring>io_uring</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/linux>linux</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/mapreduce>mapreduce</a>
<span class=category-list-count>3</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/posix>posix</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/programming>programming</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/reactive>reactive</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/redis>redis</a>
<span class=category-list-count>4</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/seastar>seastar</a>
<span class=category-list-count>1</span></li></ul></div></div><div class=widget-wrap><h3 class=widget-title>Tag cloud</h3><div class="widget tagcloud"><a href=https://romange.github.io/blog/preview/tags/asynchronous style=font-size:12px>asynchronous</a>
<a href=https://romange.github.io/blog/preview/tags/backend style=font-size:12px>backend</a>
<a href=https://romange.github.io/blog/preview/tags/blogging style=font-size:12px>blogging</a>
<a href=https://romange.github.io/blog/preview/tags/c++ style=font-size:12px>c++</a>
<a href=https://romange.github.io/blog/preview/tags/code-generation style=font-size:12px>code-generation</a>
<a href=https://romange.github.io/blog/preview/tags/concurrency style=font-size:12px>concurrency</a>
<a href=https://romange.github.io/blog/preview/tags/dragonfly style=font-size:12px>dragonfly</a>
<a href=https://romange.github.io/blog/preview/tags/fibers style=font-size:12px>fibers</a>
<a href=https://romange.github.io/blog/preview/tags/gaia style=font-size:12px>gaia</a>
<a href=https://romange.github.io/blog/preview/tags/io_uring style=font-size:12px>io_uring</a>
<a href=https://romange.github.io/blog/preview/tags/linux style=font-size:12px>linux</a>
<a href=https://romange.github.io/blog/preview/tags/mapreduce style=font-size:12px>mapreduce</a>
<a href=https://romange.github.io/blog/preview/tags/posix style=font-size:12px>posix</a>
<a href=https://romange.github.io/blog/preview/tags/programming style=font-size:12px>programming</a>
<a href=https://romange.github.io/blog/preview/tags/reactive style=font-size:12px>reactive</a>
<a href=https://romange.github.io/blog/preview/tags/redis style=font-size:12px>redis</a>
<a href=https://romange.github.io/blog/preview/tags/seastar style=font-size:12px>seastar</a></div></div><div id=toTop class="fa fa-angle-up"></div></aside></div></div><footer id=footer><div class=outer><div id=footer-info class=inner>&copy; 2022
Roman Gershman</div></div></footer><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-107146718-1","auto"),ga("send","pageview"))</script><script src=https://romange.github.io/blog/preview/fancybox/jquery.fancybox.pack.js></script>
<script src=https://romange.github.io/blog/preview/js/script.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js></script>
<script>hljs.initHighlightingOnLoad()</script><script type=text/x-mathjax-config>
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>