<!doctype html><html lang=en-us><head><title>Gaia Mapreduce Tutorial - part1 &#183; These are the wrong sort of bees</title><meta name=generator content="Hugo 0.104.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=author content="Roman Gershman"><meta name=description content="The wrong sort of bees"><link rel=canonical href=https://romange.github.io/blog/preview/2019/07/15/gaia-mapreduce-tutorial-part1/><link rel=icon href=https://romange.github.io/blog/preview/favicon.ico><link rel=apple-touch-icon href=https://romange.github.io/blog/preview/apple-touch-icon.png><link rel=stylesheet href=https://romange.github.io/blog/preview/css/style.css><link rel=stylesheet href=https://romange.github.io/blog/preview/css/font-awesome.min.css><link rel=stylesheet href=https://romange.github.io/blog/preview/css/monokai.css><link rel=stylesheet href=https://romange.github.io/blog/preview/fancybox/jquery.fancybox.css><link href='https://fonts.googleapis.com/css?family=Open+Sans:400italic,400,600' rel=stylesheet type=text/css><link href='https://fonts.googleapis.com/css?family=Source+Code+Pro' rel=stylesheet type=text/css><meta property="og:title" content="Gaia Mapreduce Tutorial - part1"><meta property="og:description" content="There are many Java-based mapreduce frameworks that exist today -
Apache Beam, Flink, Apex are to name few.
GAIA-MR is my attempt to show advantages of a C++ over other languages in this domain.
It&rsquo;s currently implemented for a single machine but even with this restriction I&rsquo;ve seen
up-to 3-7 times reduction in cost and running time vs current alternatives.
Please note that the single machine restriction put a hard limit on how much data we can process, nethertheless GAIA-MR shines with small-to-medium size workloads (~1TB). This part gives an introduction about mapreduce in general."><meta property="og:type" content="article"><meta property="og:url" content="https://romange.github.io/blog/preview/2019/07/15/gaia-mapreduce-tutorial-part1/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-07-15T00:00:35+03:00"><meta property="article:modified_time" content="2019-07-15T00:00:35+03:00"><meta itemprop=name content="Gaia Mapreduce Tutorial - part1"><meta itemprop=description content="There are many Java-based mapreduce frameworks that exist today -
Apache Beam, Flink, Apex are to name few.
GAIA-MR is my attempt to show advantages of a C++ over other languages in this domain.
It&rsquo;s currently implemented for a single machine but even with this restriction I&rsquo;ve seen
up-to 3-7 times reduction in cost and running time vs current alternatives.
Please note that the single machine restriction put a hard limit on how much data we can process, nethertheless GAIA-MR shines with small-to-medium size workloads (~1TB). This part gives an introduction about mapreduce in general."><meta itemprop=datePublished content="2019-07-15T00:00:35+03:00"><meta itemprop=dateModified content="2019-07-15T00:00:35+03:00"><meta itemprop=wordCount content="1132"><meta itemprop=keywords content="c++,mapreduce,gaia,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Gaia Mapreduce Tutorial - part1"><meta name=twitter:description content="There are many Java-based mapreduce frameworks that exist today -
Apache Beam, Flink, Apex are to name few.
GAIA-MR is my attempt to show advantages of a C++ over other languages in this domain.
It&rsquo;s currently implemented for a single machine but even with this restriction I&rsquo;ve seen
up-to 3-7 times reduction in cost and running time vs current alternatives.
Please note that the single machine restriction put a hard limit on how much data we can process, nethertheless GAIA-MR shines with small-to-medium size workloads (~1TB). This part gives an introduction about mapreduce in general."><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js></script></head><body><div class=container><div id=container><header id=header><div id=header-main class=header-inner><div class=outer><a href=https://romange.github.io/blog/preview/ id=logo><i class=logo style=background-image:url(https://romange.github.io/blog/preview/css/images/7.png)></i>
<span class=site-title>These are the wrong sort of bees</span></a><nav id=main-nav><a class=main-nav-link href=https://romange.github.io/blog/preview/tags/>Tags</a>
<a class=main-nav-link href=https://romange.github.io/blog/preview/about/>About</a></nav><nav id=sub-nav><div class=profile id=profile-nav><a id=profile-anchor href=javascript:;><img class=avatar src=https://romange.github.io/blog/preview/css/images/avatar.png><i class="fa fa-caret-down"></i></a></div></nav><div id=search-form-wrap><form action=//google.com/search method=get accept-charset=utf-8 class=search-form><input type=search name=q class=search-form-input placeholder=Search>
<button type=submit class=search-form-submit></button>
<input type=hidden name=sitesearch value=https://romange.github.io/blog/preview/></form></div></div></div><div id=main-nav-mobile class="header-sub header-inner"><table class="menu outer"><tbody><tr><td><a class=main-nav-link href=https://romange.github.io/blog/preview/tags/>Tags</a></td><td><a class=main-nav-link href=https://romange.github.io/blog/preview/about/>About</a></td><td><form action=//google.com/search method=get accept-charset=utf-8 class=search-form><input type=search name=q class=search-form-input placeholder=Search>
<input type=hidden name=sitesearch value=https://romange.github.io/blog/preview/></form></td></tr></tbody></table></div></header><div class=outer><aside id=profile><div class="inner profile-inner"><div class="base-info profile-block"><img id=avatar src="https://www.gravatar.com/avatar/4a203a48eb1cdb1b8c47d008f0c139c9?s=100&d=identicon"><h2 id=name>Roman Gershman</h2><h3 id=title>Software Engineer</h3><span id=location><i class="fa fa-map-marker"></i>Tel Aviv</span>
<a id=follow href=https://github.com/romange>Follow</a></div><div class="article-info profile-block"><div class=article-info-block>14
<span>Posts</span></div><div class=article-info-block>17
<span>Tags</span></div></div><div class="profile-block social-links"><table><tr><td><a href=//github.com/romange target=_blank title=GitHub><i class="fa fa-github"></i></a></td><td><a href=//linkedin.com/in/romange target=_blank title=LinkedIn><i class="fa fa-linkedin"></i></a></td><td><a href=//stackoverflow.com/users/romange target=_blank title="Stack Overflow"><i class="fa fa-stack-overflow"></i></a></td><td><a href=https://romange.github.io/blog/preview/index.xml target=_blank title=RSS><i class="fa fa-rss"></i></a></td></tr></table></div></div></aside><section id=main><article id=page-undefined class="article article-type-page" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><a href=https://romange.github.io/blog/preview/2019/07/15/gaia-mapreduce-tutorial-part1/><h1 class=article-title itemprop=name>Gaia Mapreduce Tutorial - part1</h1></a><div class=article-meta><div class=article-date><i class="fa fa-calendar"></i>
<time datetime="2019-07-15 00:00:35 +0300 +0300" itemprop=datePublished>Jul 15nd 2019</time>
&#183;
1132
words
&#183;
6
minute read</div><div class=article-category><i class="fa fa-tags"></i>
<a class=article-category-link href=https://romange.github.io/blog/preview/tags/c++>c++</a>
&#183;
<a class=article-category-link href=https://romange.github.io/blog/preview/tags/mapreduce>mapreduce</a>
&#183;
<a class=article-category-link href=https://romange.github.io/blog/preview/tags/gaia>gaia</a></div></div></header><div class=article-entry itemprop=articleBody><p>There are many Java-based mapreduce frameworks that exist today -
Apache <a href=https://beam.apache.org/>Beam</a>, <a href=https://flink.apache.org/>Flink</a>, <a href=https://apex.apache.org/>Apex</a> are to name few.</p><p><a href=https://github.com/romange/gaia>GAIA-MR</a> is my attempt to show advantages of a C++ over other languages in this domain.
It&rsquo;s currently implemented for a single machine but even with this restriction I&rsquo;ve seen
up-to 3-7 times reduction in cost and running time vs current alternatives.</p><p>Please note that the single machine restriction put a hard limit on how much data we can process, nethertheless GAIA-MR shines with small-to-medium size workloads (~1TB). This part gives an introduction about mapreduce in general.</p><h2 id=background>Background</h2><p>Before I start explaining about GAIA, I would like to explain what MapReduce is for.
Originally, <a href=https://research.google.com/archive/mapreduce-osdi04.pdf>it was introduced by Google</a>
and then was quickly picked up by the industry and rebranded externally as Hadoop.</p><p>A mapreduce algorithm is a glorified <code>GroupBy</code> or <code>HashJoin</code> operation from the DB world.
Its purpose is to go over (big) data (I hate this term!) and transform it in such a way that pieces of information dispersed across different sources could be grouped for further processing.</p><p>One of the big advantages of Mapreduce framework is that it allows clean separation between low-level mechanics like multi-threading,
multi-machine communication, disk-based algorithms, external data structures,
efficient I/O optimization, etc - on the one side,
and user-provided pipeline logic on the other side.
Another advantage is virtualization of resources that allows the framework
to run over multiple CPUs,
multiple disks and machines in a way that is semi-transparent to a user.</p><p>In other words, a user may focus on his high-level processing task.
All this of course as long as his algorithm can be modeled with one or more MapReduce steps.</p><h4 id=mapreduce-step>Mapreduce Step</h4><p>A mapreduce step is essentially combined from 2 operators: a mapper and a reducer.
Mappers go over 1 or more different input sources comprised of mutually independent records.
A mapper reads each record, applies user-supplied data transformation, possibly filters out or
extends records with more data and then partitions its output according to some rule.
Mappers can multiply the amount of incoming data by some factor or reduce it to almost nothing.
The main restriction they have is that mappers do not control which records exactly they are gonna process
and they should not assume how many mapper processors will run. They run independently from each other
and usually do not pass information between them.</p><p>See <img src=/img/MapReduce-Tutorial-1.png alt="Map Reduce Step"></p><p>Reducers, on the other hand, read already partitioned data. The data is essentially grouped together according to user-supplied criteria into multiple groups, or as we call them &ldquo;shards&rdquo;.
Usually those &ldquo;shards&rdquo; can be loaded fully into RAM.</p><p>Suppose, for example, WalMart wants to join last 10 years of its buyer transactions with another dataset of their buyers personal details. Both sources should be joined by user id but unfortunately they can not be loaded into RAM due to their huge size.
Not to worry - Mapreduce to the rescue!</p><p>We can provide a mapper that just output records from each dataset into
intermediate shards using <code>user_id % N</code> rule. Thus we produce <code>N</code> shards for each dataset.
The mapreduce will colocate information about each user in a single shard per source
at the end of the mapping phase using the sharding function <code>user_id % N</code>.
N must be large enough to allow loading of each shard into workers memory.
The mapping step of moving randomly distributed records from the input dataset to partitioned one
allows us performing the next step.</p><p><img src=/img/mr1.png alt="Wallmart Join"></p><p>Reducer processors load shards <code>Transaction'(i)</code> and <code>UserData'(i)</code> into RAM. Those shards produced by mappers and they contain all the records for which <code>user_id % N = i</code>. After loading those shards, reducers can join them using hash-join
or merge sort algorithms. Eventually, reducers produce N output shards that contain the joined information.
See the picture above. Therefore, sharding allows reducing the size of the minimal working set
to one that can fit into RAM.</p><h4 id=classic-mapreduce-flow-and-the-api>Classic mapreduce flow and the API</h4><p>Usually a framework is configured by providing instantiations of mapper or reducer classes.</p><p>For example, a mapper class may look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Mapper</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Map(RecordType input, Context<span style=color:#f92672>&lt;</span>OutputType<span style=color:#f92672>&gt;*</span> context);
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>  };
</span></span></code></pre></div><p>It might have a function <code>void Map(RecordType input, Context&lt;OutputType>* context)</code>
that is implemented by pipeline developer. This function should contain pipeline specific logic
and it can call <code>context->Write(shard_id, joined_key, map_output)</code> any number of times.
The framework instantiates mapper classes on multiple machines processes, passes input data to them,
stores intermediate shards produced by mappers and finally sorts and partitions them.</p><p>After all the framework instantiates reducer classes. A reducer class might look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Reducer</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Reduce(KeyType key, Stream<span style=color:#f92672>&lt;</span>ValueType<span style=color:#f92672>&gt;&amp;</span> stream, Writer<span style=color:#f92672>&lt;</span>OutputType<span style=color:#f92672>&gt;*</span> writer);
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>  };
</span></span></code></pre></div><h4 id=reduce-api>Reduce API</h4><p><code>Reduce</code> will be called with joined key and a stream of values corresponding to that key.
In our walmart example, the <code>key</code> would be user_id and <code>Stream&lt;ValueType></code> will contain all
the transactions for that user and his own user data from the second dataset.
Each <code>key</code> will be sent to exactly one reducer that processes its shard.
<code>Reduce</code> will be called by the framework for each key and will be able to output
its final result via <code>Writer</code>. Reducers and Mappers do not talk with each other and usually behave
like independent entities.</p><p>A classic Reducer interface guarantees to provide us each key with its values grouped.
In order to do this, the mapreduce framework is usually required to shuffle and sort the intermediate shards before
applying reducers on them. Therefore, having values colocated together with their keys <strong>requires additional I/O:
we need to load each shard, sort it and write again</strong>. This way we will be able to keep file iterators per each
sorted shard and reduce on them with <code>O(N)</code> complexity by just seeking over the files.</p><h4 id=gaia-mr>GAIA MR</h4><p><a href=https://github.com/romange/gaia>GAIA-MR</a> provides weaker guarantees than most of modern MR frameworks today: it provides shard-level abstraction by moving the responsibility for row level functionality back to the developer.</p><p>By weakening its guarantees, GAIA-MR succeeds to reduce redundant I/O for many use-cases. As a result, instead of implementing merge-sort in the framework, GAIA-MR allows a user to perform hash-join in its user code. Using modern, cache friendly data structures provided together with GAIA framework, a user can implement hash-table join with just few lines of code. Instead of trusting the generic framework on how to do optimizations, I trust a developer to fit his code to specific problem he is trying to solve.
In the next post I will go-over the concrete example and show how we can write a mapreduce pipeline in GAIA-MR.</p><p>In addition, its thread-per-core, horizontally scalable architecture allow loading machines of any size
thus adapting hardware configuration to pipeline size and complexity. This is especially useful for
cloud environments where you can relatively easily setup a machine for your needs.</p></div><footer class=article-footer><a data-url=https://romange.github.io/blog/preview/2019/07/15/gaia-mapreduce-tutorial-part1/ data-id=aed62fb9014e926b0ac5e49c0a59d38d class=article-share-link><i class="fa fa-share"></i>
Share</a>
<a href=https://romange.github.io/blog/preview/2019/07/15/gaia-mapreduce-tutorial-part1/#disqus_thread class=article-comment-link>Comments</a>
<script>(function(e){if(typeof __SHARE_BUTTON_BINDED__=="undefined"||!__SHARE_BUTTON_BINDED__)__SHARE_BUTTON_BINDED__=!0;else return;e("body").on("click",function(){e(".article-share-box.on").removeClass("on")}).on("click",".article-share-link",function(t){t.stopPropagation();var n,c,o=e(this),a=o.attr("data-url"),s=encodeURIComponent(a),i="article-share-box-"+o.attr("data-id"),r=o.offset();if(e("#"+i).length){if(n=e("#"+i),n.hasClass("on")){n.removeClass("on");return}}else c=['<div id="'+i+'" class="article-share-box">','<input class="article-share-input" value="'+a+'">','<div class="article-share-links">','<a href="https://twitter.com/intent/tweet?url='+s+'" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>','<a href="https://www.facebook.com/sharer.php?u='+s+'" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>','<a href="http://pinterest.com/pin/create/button/?url='+s+'" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>','<a href="https://plus.google.com/share?url='+s+'" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',"</div>","</div>"].join(""),n=e(c),e("body").append(n);e(".article-share-box.on").hide(),n.css({top:r.top+25,left:r.left}).addClass("on")}).on("click",".article-share-box",function(e){e.stopPropagation()}).on("click",".article-share-box-input",function(){e(this).select()}).on("click",".article-share-box-link",function(e){e.preventDefault(),e.stopPropagation(),window.open(this.href,"article-share-box-window-"+Date.now(),"width=500,height=450")})})(jQuery)</script></footer></div><nav id=article-nav><a href=https://romange.github.io/blog/preview/2018/12/15/introduction-to-fibers-in-c-/ id=article-nav-older class=article-nav-link-wrap><strong class=article-nav-caption>Older</strong><div class=article-nav-title>Introduction to fibers in c++</div></a><a href=https://romange.github.io/blog/preview/2019/07/25/benchmarking-gaia-mr-on-google-cloud/ id=article-nav-newer class=article-nav-link-wrap><strong class=article-nav-caption>Newer</strong><div class=article-nav-title>Benchmarking GAIA MR on Google cloud</div></a></nav></article><section id=comments><div id=disqus_thread><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//romange.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></section></section><aside id=sidebar><div class=widget-wrap><h3 class=widget-title>Recents</h3><div class=widget><ul id=recent-post><li><div class=item-thumbnail><a href=https://romange.github.io/blog/preview/2022/06/23/dragonfly-cache-design/ class=thumbnail><span class="thumbnail-image thumbnail-none"></span></a></div><div class=item-inner><p class=item-title><a href=https://romange.github.io/blog/preview/2022/06/23/dragonfly-cache-design/ class=title>Dragonfly Cache Design</a></p><p class=item-date><time datetime="2022-06-23 12:00:00 +0300 +0300" itemprop=datePublished>Jun 23nd 2022</time></p></div></li><li><div class=item-thumbnail><a href=https://romange.github.io/blog/preview/2022/01/30/redis-analysis-part-2-simplicity/ class=thumbnail><span style=background-image:url(https://romange.github.io/blog/preview/banners/simple.jpg) alt="Gaia Mapreduce Tutorial - part1" class=thumbnail-image></span></a></div><div class=item-inner><p class=item-title><a href=https://romange.github.io/blog/preview/2022/01/30/redis-analysis-part-2-simplicity/ class=title>Redis Analysis - Part 2: Simplicity</a></p><p class=item-date><time datetime="2022-01-30 20:00:00 +0200 +0200" itemprop=datePublished>Jan 30nd 2022</time></p></div></li><li><div class=item-thumbnail><a href=https://romange.github.io/blog/preview/2021/12/09/redis-analysis-part-1-threading-model/ class=thumbnail><span style=background-image:url(https://romange.github.io/blog/preview/banners/jet.jpg) alt="Gaia Mapreduce Tutorial - part1" class=thumbnail-image></span></a></div><div class=item-inner><p class=item-title><a href=https://romange.github.io/blog/preview/2021/12/09/redis-analysis-part-1-threading-model/ class=title>Redis Analysis - Part 1: Threading model</a></p><p class=item-date><time datetime="2021-12-09 11:00:00 +0300 +0300" itemprop=datePublished>Dec 9nd 2021</time></p></div></li><li><div class=item-thumbnail><a href=https://romange.github.io/blog/preview/2021/11/28/a-prelude-to-analysis-of-redis-memory-store/ class=thumbnail><span style=background-image:url(https://romange.github.io/blog/preview/banners/1200px-Redis_Logo.svg.png) alt="Gaia Mapreduce Tutorial - part1" class=thumbnail-image></span></a></div><div class=item-inner><p class=item-title><a href=https://romange.github.io/blog/preview/2021/11/28/a-prelude-to-analysis-of-redis-memory-store/ class=title>A prelude to analysis of Redis memory-store</a></p><p class=item-date><time datetime="2021-11-28 17:46:19 +0300 +0300" itemprop=datePublished>Nov 28nd 2021</time></p></div></li><li><div class=item-thumbnail><a href=https://romange.github.io/blog/preview/2020/09/05/io_uring-powered-event-loop-with-efficient-message-passing/ class=thumbnail><span class="thumbnail-image thumbnail-none"></span></a></div><div class=item-inner><p class=item-title><a href=https://romange.github.io/blog/preview/2020/09/05/io_uring-powered-event-loop-with-efficient-message-passing/ class=title>IO_URING powered event-loop with efficient message passing</a></p><p class=item-date><time datetime="2020-09-05 20:30:11 +0300 +0300" itemprop=datePublished>Sep 5nd 2020</time></p></div></li></ul></div></div><div class=widget-wrap><h3 class=widget-title>Tags</h3><div class=widget><ul class=category-list><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/asynchronous>asynchronous</a>
<span class=category-list-count>2</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/backend>backend</a>
<span class=category-list-count>2</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/blogging>blogging</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/c++>c++</a>
<span class=category-list-count>8</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/code-generation>code-generation</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/concurrency>concurrency</a>
<span class=category-list-count>2</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/dragonfly>dragonfly</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/fibers>fibers</a>
<span class=category-list-count>2</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/gaia>gaia</a>
<span class=category-list-count>3</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/io_uring>io_uring</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/linux>linux</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/mapreduce>mapreduce</a>
<span class=category-list-count>3</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/posix>posix</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/programming>programming</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/reactive>reactive</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/redis>redis</a>
<span class=category-list-count>4</span></li><li class=category-list-item><a class=category-list-link href=https://romange.github.io/blog/preview/tags/seastar>seastar</a>
<span class=category-list-count>1</span></li></ul></div></div><div class=widget-wrap><h3 class=widget-title>Tag cloud</h3><div class="widget tagcloud"><a href=https://romange.github.io/blog/preview/tags/asynchronous style=font-size:12px>asynchronous</a>
<a href=https://romange.github.io/blog/preview/tags/backend style=font-size:12px>backend</a>
<a href=https://romange.github.io/blog/preview/tags/blogging style=font-size:12px>blogging</a>
<a href=https://romange.github.io/blog/preview/tags/c++ style=font-size:12px>c++</a>
<a href=https://romange.github.io/blog/preview/tags/code-generation style=font-size:12px>code-generation</a>
<a href=https://romange.github.io/blog/preview/tags/concurrency style=font-size:12px>concurrency</a>
<a href=https://romange.github.io/blog/preview/tags/dragonfly style=font-size:12px>dragonfly</a>
<a href=https://romange.github.io/blog/preview/tags/fibers style=font-size:12px>fibers</a>
<a href=https://romange.github.io/blog/preview/tags/gaia style=font-size:12px>gaia</a>
<a href=https://romange.github.io/blog/preview/tags/io_uring style=font-size:12px>io_uring</a>
<a href=https://romange.github.io/blog/preview/tags/linux style=font-size:12px>linux</a>
<a href=https://romange.github.io/blog/preview/tags/mapreduce style=font-size:12px>mapreduce</a>
<a href=https://romange.github.io/blog/preview/tags/posix style=font-size:12px>posix</a>
<a href=https://romange.github.io/blog/preview/tags/programming style=font-size:12px>programming</a>
<a href=https://romange.github.io/blog/preview/tags/reactive style=font-size:12px>reactive</a>
<a href=https://romange.github.io/blog/preview/tags/redis style=font-size:12px>redis</a>
<a href=https://romange.github.io/blog/preview/tags/seastar style=font-size:12px>seastar</a></div></div><div id=toTop class="fa fa-angle-up"></div></aside></div></div><footer id=footer><div class=outer><div id=footer-info class=inner>&copy; 2022
Roman Gershman</div></div></footer><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-107146718-1","auto"),ga("send","pageview"))</script><script src=https://romange.github.io/blog/preview/fancybox/jquery.fancybox.pack.js></script>
<script src=https://romange.github.io/blog/preview/js/script.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js></script>
<script>hljs.initHighlightingOnLoad()</script><script type=text/x-mathjax-config>
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>