<!doctype html><html lang=en-us><head><title>Seastar - Asynchronous C++ framework &#183; These are the wrong sort of bees</title><meta name=generator content="Hugo 0.104.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=author content="Roman Gershman"><meta name=description content="The wrong sort of bees"><link rel=canonical href=https://www.romange.com/2018/07/12/seastar-asynchronous-c-framework/><link rel=icon href=https://www.romange.com/favicon.ico><link rel=apple-touch-icon href=https://www.romange.com/apple-touch-icon.png><link rel=stylesheet href=https://www.romange.com/css/style.css><link rel=stylesheet href=https://www.romange.com/css/font-awesome.min.css><link rel=stylesheet href=https://www.romange.com/css/monokai.css><link rel=stylesheet href=https://www.romange.com/fancybox/jquery.fancybox.css><link href='https://fonts.googleapis.com/css?family=Open+Sans:400italic,400,600' rel=stylesheet type=text/css><link href='https://fonts.googleapis.com/css?family=Source+Code+Pro' rel=stylesheet type=text/css><meta property="og:title" content="Seastar - Asynchronous C++ framework"><meta property="og:description" content="Lately, there are many discussions in the programming community in general and in c++ community in particular on how to write efficient asynchronous code. Many concepts like futures, continuations, coroutines are being discussed by c++ standard
committee but not much progress was made besides very minimal support of C++11 futures.
On the other hand, many mainstream programming languages progressed quicker and adopted asynchronous models
either into a core language or popularized it via standard libraries.
For example, Python (yield) and Lua use coroutines to achieve asynchronisity, java uses continuations and futures,  golang and Erlang use green threads, and C and Javascript use callback based actor models.
However, C++ historically lacked the official support for asynchronous programming, which forced
the community to introduce ad-hoc frameworks and libraries that provided this functionality.
I would like to share my opinion on what I think will be the best direction for asynchronous models in C++ by reviewing two
prominent frameworks: Seastar and Boost.Fiber. This (opinionated) post reviews Seastar."><meta property="og:type" content="article"><meta property="og:url" content="https://www.romange.com/2018/07/12/seastar-asynchronous-c-framework/"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-07-12T20:45:24+03:00"><meta property="article:modified_time" content="2018-07-12T20:45:24+03:00"><meta itemprop=name content="Seastar - Asynchronous C++ framework"><meta itemprop=description content="Lately, there are many discussions in the programming community in general and in c++ community in particular on how to write efficient asynchronous code. Many concepts like futures, continuations, coroutines are being discussed by c++ standard
committee but not much progress was made besides very minimal support of C++11 futures.
On the other hand, many mainstream programming languages progressed quicker and adopted asynchronous models
either into a core language or popularized it via standard libraries.
For example, Python (yield) and Lua use coroutines to achieve asynchronisity, java uses continuations and futures,  golang and Erlang use green threads, and C and Javascript use callback based actor models.
However, C++ historically lacked the official support for asynchronous programming, which forced
the community to introduce ad-hoc frameworks and libraries that provided this functionality.
I would like to share my opinion on what I think will be the best direction for asynchronous models in C++ by reviewing two
prominent frameworks: Seastar and Boost.Fiber. This (opinionated) post reviews Seastar."><meta itemprop=datePublished content="2018-07-12T20:45:24+03:00"><meta itemprop=dateModified content="2018-07-12T20:45:24+03:00"><meta itemprop=wordCount content="1601"><meta itemprop=keywords content="concurrency,asynchronous,seastar,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Seastar - Asynchronous C++ framework"><meta name=twitter:description content="Lately, there are many discussions in the programming community in general and in c++ community in particular on how to write efficient asynchronous code. Many concepts like futures, continuations, coroutines are being discussed by c++ standard
committee but not much progress was made besides very minimal support of C++11 futures.
On the other hand, many mainstream programming languages progressed quicker and adopted asynchronous models
either into a core language or popularized it via standard libraries.
For example, Python (yield) and Lua use coroutines to achieve asynchronisity, java uses continuations and futures,  golang and Erlang use green threads, and C and Javascript use callback based actor models.
However, C++ historically lacked the official support for asynchronous programming, which forced
the community to introduce ad-hoc frameworks and libraries that provided this functionality.
I would like to share my opinion on what I think will be the best direction for asynchronous models in C++ by reviewing two
prominent frameworks: Seastar and Boost.Fiber. This (opinionated) post reviews Seastar."><meta name=twitter:site content="@romanger"><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js></script></head><body><div class=container><div id=container><header id=header><div id=header-main class=header-inner><div class=outer><a href=https://www.romange.com/ id=logo><i class=logo style=background-image:url(https://www.romange.com/css/images/7.png)></i>
<span class=site-title>These are the wrong sort of bees</span></a><nav id=main-nav><a class=main-nav-link href=https://www.romange.com/tags/>Tags</a>
<a class=main-nav-link href=https://www.romange.com/about/>About</a></nav><nav id=sub-nav><div class=profile id=profile-nav><a id=profile-anchor href=javascript:;><img class=avatar src=https://www.romange.com/css/images/avatar.png><i class="fa fa-caret-down"></i></a></div></nav><div id=search-form-wrap><form action=//google.com/search method=get accept-charset=utf-8 class=search-form><input type=search name=q class=search-form-input placeholder=Search>
<button type=submit class=search-form-submit></button>
<input type=hidden name=sitesearch value=https://www.romange.com/></form></div></div></div><div id=main-nav-mobile class="header-sub header-inner"><table class="menu outer"><tbody><tr><td><a class=main-nav-link href=https://www.romange.com/tags/>Tags</a></td><td><a class=main-nav-link href=https://www.romange.com/about/>About</a></td><td><form action=//google.com/search method=get accept-charset=utf-8 class=search-form><input type=search name=q class=search-form-input placeholder=Search>
<input type=hidden name=sitesearch value=https://www.romange.com/></form></td></tr></tbody></table></div></header><div class=outer><aside id=profile><div class="inner profile-inner"><div class="base-info profile-block"><img id=avatar src="https://www.gravatar.com/avatar/4a203a48eb1cdb1b8c47d008f0c139c9?s=100&d=identicon"><h2 id=name>Roman Gershman</h2><h3 id=title>Software Engineer</h3><span id=location><i class="fa fa-map-marker"></i>Tel Aviv</span>
<a id=follow href=https://github.com/romange>Follow</a></div><div class="article-info profile-block"><div class=article-info-block>13
<span>Posts</span></div><div class=article-info-block>16
<span>Tags</span></div></div><div class="profile-block social-links"><table><tr><td><a href=//github.com/romange target=_blank title=GitHub><i class="fa fa-github"></i></a></td><td><a href=//linkedin.com/in/romange target=_blank title=LinkedIn><i class="fa fa-linkedin"></i></a></td><td><a href=//stackoverflow.com/users/romange target=_blank title="Stack Overflow"><i class="fa fa-stack-overflow"></i></a></td><td><a href=//twitter.com/romanger target=_blank title=Twitter><i class="fa fa-twitter"></i></a></td><td><a href=https://www.romange.com/index.xml target=_blank title=RSS><i class="fa fa-rss"></i></a></td></tr></table></div></div></aside><section id=main><article id=page-undefined class="article article-type-page" itemscope itemprop=blogPost><div class=article-inner><img src=https://www.romange.com/banners/seastar.png class=article-banner><header class=article-header><a href=https://www.romange.com/2018/07/12/seastar-asynchronous-c-framework/><h1 class=article-title itemprop=name>Seastar - Asynchronous C++ framework</h1></a><div class=article-meta><div class=article-date><i class="fa fa-calendar"></i>
<time datetime="2018-07-12 20:45:24 +0300 +0300" itemprop=datePublished>Jul 12nd 2018</time>
&#183;
1601
words
&#183;
8
minute read</div><div class=article-category><i class="fa fa-tags"></i>
<a class=article-category-link href=https://www.romange.com/tags/concurrency>concurrency</a>
&#183;
<a class=article-category-link href=https://www.romange.com/tags/asynchronous>asynchronous</a>
&#183;
<a class=article-category-link href=https://www.romange.com/tags/seastar>seastar</a></div></div></header><div class=article-entry itemprop=articleBody><p>Lately, there are many discussions in the programming community in general and in c++ community in particular on how to write efficient asynchronous code. Many concepts like futures, continuations, coroutines are being discussed by c++ standard
committee but not much progress was made besides very minimal support of C++11 futures.</p><p>On the other hand, many mainstream programming languages progressed quicker and adopted asynchronous models
either into a core language or popularized it via standard libraries.
For example, Python (yield) and Lua use coroutines to achieve asynchronisity, java uses continuations and futures, golang and Erlang use green threads, and C and Javascript use callback based actor models.
However, C++ historically lacked the official support for asynchronous programming, which forced
the community to introduce ad-hoc frameworks and libraries that provided this functionality.</p><p>I would like to share my opinion on what I think will be the best direction for asynchronous models in C++ by reviewing two
prominent frameworks: <a href=http://seastar.io/>Seastar</a> and <a href=https://boost.org/doc/libs/1_67_0/libs/fiber/doc/html/index.html>Boost.Fiber</a>. This (opinionated) post reviews Seastar.</p><h1 id=seastar>Seastar</h1><p>Before I talk about Seastar I want to describe the problem that asynchronous programming models solve
the way I see it:</p><p><strong>Given a single execution thread</strong> and a program flow consisting of potentially blocking task
how can we write a program that fully utilizes this thread. &ldquo;fully utilizes&rdquo; in this context means that the execution thread
won&rsquo;t sleep as long as there are any (CPU) tasks that could be performed.</p><p>Please note that asynchronous programming is not the same as multi-threading even though
multi-threading might provide a workaround to a similar problem: <strong>Given a single CPU core</strong> how can we
write a program that fully utilizes this CPU. Asynchronous programming here is discussed only in
the context of a single thread, even though many models provide a complete solution for both asynchronous
programming and multi-threaded environments.</p><p>Seastar is a power-horse behind a very efficient Nosql database <a href=https://scylladb.com>ScyllaDB</a> and
is developed by a very talented team of world-class developers. Seastar is a framework that adopts <a href=https://en.wikipedia.org/wiki/Continuation-passing_style>continuation-passing style</a> (CSP) of writing fully asynchronous code.</p><p>CSP programming solves asynchronous programming by breaking the program flow into CPU-only tasks
that should not block any IO requests. Each IO request returns a future object describing the result.
Program flow is extended by appending to a future a possible continuation - either a cpu-task or another io-request.</p><p>The Seastar framework itself has proven to be very efficient. In fact, it allows responding to requests
with sub-millisecond latencies (even at 99nth percentile) and scale linearly in the number of cores.
It has been used already in <a href=http://seastar.io/seastar-applications/>a few projects</a> and
gave consistently superior performance compared to the existing alternatives.</p><p>Seastar shows the true potential of the hardware it utilizes. It has lots of pre-built constructs
to cover many synchronization scenarios and I think it&rsquo;s a perfect candidate to analyze how futures
and continuations code might look in C++.</p><h2 id=scopes-and-execution-context>Scopes and execution context</h2><p>Right from the start, it was hard for me to get used to the unique style of writing CSP.
The problem is common to Java futures as well, not just to C++ or Seastar.</p><p>Consider, for example, the following code taken from Seastar&rsquo;s wiki page.
It starts a listener loop on port 1234 that accepts server connections.
For each accepted connection, it writes a response into the socket and then closes it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>seastar<span style=color:#f92672>::</span>future<span style=color:#f92672>&lt;&gt;</span> service_loop() {
</span></span><span style=display:flex><span>    seastar<span style=color:#f92672>::</span>listen_options lo;
</span></span><span style=display:flex><span>    lo.reuse_address <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> seastar<span style=color:#f92672>::</span>do_with(seastar<span style=color:#f92672>::</span>listen(seastar<span style=color:#f92672>::</span>make_ipv4_address({<span style=color:#ae81ff>1234</span>}), lo),
</span></span><span style=display:flex><span>            [] (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> listener) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> seastar<span style=color:#f92672>::</span>keep_doing([<span style=color:#f92672>&amp;</span>listener] () {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> listener.accept().then(
</span></span><span style=display:flex><span>                [] (seastar<span style=color:#f92672>::</span>connected_socket s, seastar<span style=color:#f92672>::</span>socket_address a) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>auto</span> out <span style=color:#f92672>=</span> s.output();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> seastar<span style=color:#f92672>::</span>do_with(std<span style=color:#f92672>::</span>move(s), std<span style=color:#f92672>::</span>move(out),
</span></span><span style=display:flex><span>                        [] (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> s, <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> out) {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>return</span> out.write(canned_response).then([<span style=color:#f92672>&amp;</span>out] {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>return</span> out.close();
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The code has a notable flow that is common to all continuation-passing frameworks.
It indents to the right with each continuation or lambda function. There are lots of lambdas involved,
which makes it very hard to follow after scope limits.</p><p>Every continuation or asynchronous function breaks the execution context, and it becomes a non-trivial effort
to reason about the flow of the program.</p><p>Now consider <code>seastar::keep_doing</code>. It is a pre-built routine that accepts an (a)synchronous function
as an argument, and allows running this function in the infinite but preemptable loop.
Why do we need such a function? Suppose our goal is to schedule <code>do_smthing_async()</code> time after time
sequentially. The function itself might block due to I/O, but we do not want to stall the execution thread.
Since we want to write fully asynchronous code, we can not just write <code>while (true) { do_smthing_async(); }</code>
because then we are trapped inside the loop. Instead <code>keep_doing</code> uses &ldquo;futurized&rdquo; recursion to run the code and schedule it again (simplified below):</p><pre tabindex=0><code>  // AsyncAction is a callback returning seastar::future&lt;&gt; des an asynchronous computation.
  template seastar::future&lt;&gt; keep_doing(AsynchAction action) {
    return action.then([action] { return keep_doing(action);});
  }
</code></pre><p>The code above is very simplified and the real Seastar code can handle many loops constructs with
synchronous or asynchronous functions. In addition, Seastar does optimizations to improve
the latency of asynchronous operations when possible. As a result, <code>keep_doing</code> provides meta
construct to tell Seastar engine about asynchronous state-machine describing a loop.
The execution thread is not blocked we schedule the loop.
Eventually, when we schedule the initial state of the program the main thread
will enter the execution loop which will start unwinding the state that was queued into the engine and execute
its asynchronous commands.</p><p>As a result, C++ language is used to create and connect Seastar data-structures that tell the Seastar framework
how to run functions instead of actually running them. Such style differs greatly from classic C++ programming.
Some native C++ constructs work differently with such flow. For example, if exceptions are thrown
in CSP code it&rsquo;s not immediately clear where to put the catch handler:
exceptions can be thrown from the code currently scheduling the io request, or alternatively,
they might be thrown from the continuation lambda when it runs. Both cases require different handling.
As a result, continuation chaining has implicit interactions that are not tracked via core language.</p><h2 id=object-life-management>Object life management.</h2><p>If following the execution context can be hard in C++, then tracking object lifecycles can be a real hell.</p><p>Unlike in Python, Java, Go, a c++ programmer is required to think about object lifecycle and with CSP
it&rsquo;s much harder even with naive looking cases. Consider the following code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>seastar<span style=color:#f92672>::</span>future<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint64_t</span><span style=color:#f92672>&gt;</span> slow_size(file f) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> seastar<span style=color:#f92672>::</span>sleep(<span style=color:#ae81ff>10</span>ms).then([f] {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> f.size();
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>f.size()</code> is implemented as an asynchronous operation because it might need to
read file attributes from the disk i.e. to block on IO. The lambda that captures <code>f</code> exits immediately
after issuing an asynchronous call <code>f.size()</code>. The asynchronous code that is gonna run by the framework requires <code>f</code> to exist, of course, but <code>f</code> captured by lambda and is gonna be destroyed after the lambda exits.
In order to prolong the object&rsquo;s life we are advised to add <code>finally([f] {})</code> which
serves as an object scoped guard for Seastar flow.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>seastar<span style=color:#f92672>::</span>future<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint64_t</span><span style=color:#f92672>&gt;</span> slow_size(file f) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> seastar<span style=color:#f92672>::</span>sleep(<span style=color:#ae81ff>10</span>ms).then([f] {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> f.size().finally([f]{});
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s see another example. Suppose we have a moveable-only class <code>pipe</code> that has an asynchronous method
<code>future&lt;> read(size_t, AsyncFunc f)</code>. <code>AsyncFunc</code> is a function that is expected to receive a future
object containing buffer contents upon successful read. With lessons learned from the previous example,
we might write the following code to keep <code>p</code> alive while lambda runs.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>future<span style=color:#f92672>&lt;&gt;</span> (pipe p) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> p.read(<span style=color:#ae81ff>16</span>, [p <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>move(p)] (<span style=color:#66d9ef>auto</span> future_buf) { handle(future_buf); ... });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Unfortunately, this code causes &ldquo;undefined behavior&rdquo; and most likely will crash because C++ does
not specify correct order for evaluating lambda capture and a function call inside the same execution statement.
So what may (and does) happen is that the compiler first moves the object <code>p</code> into the lambda and
then calls <code>p.read(..)</code> on already undefined object <code>p</code>.
The workaround to this problem is to use <code>shared_ptr</code> to allow copy semantics and pay attention to captures that move objects.</p><p>As you can see using CSP in C++ is not a trivial matter and I showed only a few issues a programmer needs to think about when he uses Seastar. Unfortunately, it&rsquo;s not Seastar to blame - it comes from the fact that C++ is not designed to describe CSP flows.</p><p>Seastar team tries to overcome those difficulties by providing building blocks for most common
synchronization patterns and for giving an idiomatic way on how to use their framework.
One of the disadvantages of this approach is that many of their utilities hide memory allocations,
which is by itself anti-idiomatic to C++. For example, their solution to the problem above is
using <code>do_with</code> construct that allows binding the scope of moveable objects to their asynchronous operations
but hides the allocation of its helper objects. As a result, the framework becomes complicated and hard to learn.</p><p>In addition, the constructs like these still do not solve the core problem - future chaining looks
confusing and unnatural in C++.</p><p>To summarize, Seastar is a very efficient framework but requires total commitment to it right from the start.
It allows you to describe fully asynchronous flows but requires lots of attention - debugging the problems might be hard.
If you decide using it, you probably won&rsquo;t be able to integrate it well with other open-source libraries,
especially with those that use synchronous system-calls, synchronization mechanisms, and multi-threading.
Despite the fact that having the CSP style of writing asynchronous code can be very tedious in C++,
hard to reason and error-prone, it&rsquo;s still possible.</p><p>In my next post I will go over <a href=https://boost.org/doc/libs/1_67_0/libs/fiber/doc/html/index.html>Boost.Fiber</a>
framework and will explain how it solves asynchronous programming but retains the original style of writing C++ programs.</p></div><footer class=article-footer><a data-url=https://www.romange.com/2018/07/12/seastar-asynchronous-c-framework/ data-id=c898dc4bc2df3f11acc490a18d2cf803 class=article-share-link><i class="fa fa-share"></i>
Share</a>
<a href=https://www.romange.com/2018/07/12/seastar-asynchronous-c-framework/#disqus_thread class=article-comment-link>Comments</a>
<script>(function(e){if(typeof __SHARE_BUTTON_BINDED__=="undefined"||!__SHARE_BUTTON_BINDED__)__SHARE_BUTTON_BINDED__=!0;else return;e("body").on("click",function(){e(".article-share-box.on").removeClass("on")}).on("click",".article-share-link",function(t){t.stopPropagation();var n,c,o=e(this),a=o.attr("data-url"),s=encodeURIComponent(a),i="article-share-box-"+o.attr("data-id"),r=o.offset();if(e("#"+i).length){if(n=e("#"+i),n.hasClass("on")){n.removeClass("on");return}}else c=['<div id="'+i+'" class="article-share-box">','<input class="article-share-input" value="'+a+'">','<div class="article-share-links">','<a href="https://twitter.com/intent/tweet?url='+s+'" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>','<a href="https://www.facebook.com/sharer.php?u='+s+'" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>','<a href="http://pinterest.com/pin/create/button/?url='+s+'" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>','<a href="https://plus.google.com/share?url='+s+'" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',"</div>","</div>"].join(""),n=e(c),e("body").append(n);e(".article-share-box.on").hide(),n.css({top:r.top+25,left:r.left}).addClass("on")}).on("click",".article-share-box",function(e){e.stopPropagation()}).on("click",".article-share-box-input",function(){e(this).select()}).on("click",".article-share-box-link",function(e){e.preventDefault(),e.stopPropagation(),window.open(this.href,"article-share-box-window-"+Date.now(),"width=500,height=450")})})(jQuery)</script></footer></div><nav id=article-nav><a href=https://www.romange.com/2017/11/02/implementing-cheap-and-precise-clock/ id=article-nav-older class=article-nav-link-wrap><strong class=article-nav-caption>Older</strong><div class=article-nav-title>Implementing cheap and precise clock</div></a><a href=https://www.romange.com/2018/12/15/introduction-to-fibers-in-c-/ id=article-nav-newer class=article-nav-link-wrap><strong class=article-nav-caption>Newer</strong><div class=article-nav-title>Introduction to fibers in c++</div></a></nav></article><section id=comments><div id=disqus_thread><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//romange.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></section></section><aside id=sidebar><div class=widget-wrap><h3 class=widget-title>Recents</h3><div class=widget><ul id=recent-post><li><div class=item-thumbnail><a href=https://www.romange.com/2022/06/23/dragonfly-cache-design/ class=thumbnail><span class="thumbnail-image thumbnail-none"></span></a></div><div class=item-inner><p class=item-title><a href=https://www.romange.com/2022/06/23/dragonfly-cache-design/ class=title>Dragonfly Cache Design</a></p><p class=item-date><time datetime="2022-06-23 12:00:00 +0300 +0300" itemprop=datePublished>Jun 23nd 2022</time></p></div></li><li><div class=item-thumbnail><a href=https://www.romange.com/2022/01/30/redis-analysis-part-2-simplicity/ class=thumbnail><span style=background-image:url(https://www.romange.com/banners/simple.jpg) alt="Seastar - Asynchronous C++ framework" class=thumbnail-image></span></a></div><div class=item-inner><p class=item-title><a href=https://www.romange.com/2022/01/30/redis-analysis-part-2-simplicity/ class=title>Redis Analysis - Part 2: Simplicity</a></p><p class=item-date><time datetime="2022-01-30 20:00:00 +0200 +0200" itemprop=datePublished>Jan 30nd 2022</time></p></div></li><li><div class=item-thumbnail><a href=https://www.romange.com/2021/12/09/redis-analysis-part-1-threading-model/ class=thumbnail><span style=background-image:url(https://www.romange.com/banners/jet.jpg) alt="Seastar - Asynchronous C++ framework" class=thumbnail-image></span></a></div><div class=item-inner><p class=item-title><a href=https://www.romange.com/2021/12/09/redis-analysis-part-1-threading-model/ class=title>Redis Analysis - Part 1: Threading model</a></p><p class=item-date><time datetime="2021-12-09 11:00:00 +0300 +0300" itemprop=datePublished>Dec 9nd 2021</time></p></div></li><li><div class=item-thumbnail><a href=https://www.romange.com/2021/11/28/a-prelude-to-analysis-of-redis-memory-store/ class=thumbnail><span style=background-image:url(https://www.romange.com/banners/1200px-Redis_Logo.svg.png) alt="Seastar - Asynchronous C++ framework" class=thumbnail-image></span></a></div><div class=item-inner><p class=item-title><a href=https://www.romange.com/2021/11/28/a-prelude-to-analysis-of-redis-memory-store/ class=title>A prelude to analysis of Redis memory-store</a></p><p class=item-date><time datetime="2021-11-28 17:46:19 +0300 +0300" itemprop=datePublished>Nov 28nd 2021</time></p></div></li><li><div class=item-thumbnail><a href=https://www.romange.com/2019/11/01/gaia-mapreduce-tutorial-part2/ class=thumbnail><span class="thumbnail-image thumbnail-none"></span></a></div><div class=item-inner><p class=item-title><a href=https://www.romange.com/2019/11/01/gaia-mapreduce-tutorial-part2/ class=title>Gaia Mapreduce Tutorial - part2</a></p><p class=item-date><time datetime="2019-11-01 10:30:12 +0300 +0300" itemprop=datePublished>Nov 1nd 2019</time></p></div></li></ul></div></div><div class=widget-wrap><h3 class=widget-title>Tags</h3><div class=widget><ul class=category-list><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/asynchronous>asynchronous</a>
<span class=category-list-count>2</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/backend>backend</a>
<span class=category-list-count>2</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/blogging>blogging</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/c++>c++</a>
<span class=category-list-count>7</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/code-generation>code-generation</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/concurrency>concurrency</a>
<span class=category-list-count>2</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/dragonfly>dragonfly</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/fibers>fibers</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/gaia>gaia</a>
<span class=category-list-count>3</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/linux>linux</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/mapreduce>mapreduce</a>
<span class=category-list-count>3</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/posix>posix</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/programming>programming</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/reactive>reactive</a>
<span class=category-list-count>1</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/redis>redis</a>
<span class=category-list-count>4</span></li><li class=category-list-item><a class=category-list-link href=https://www.romange.com/tags/seastar>seastar</a>
<span class=category-list-count>1</span></li></ul></div></div><div class=widget-wrap><h3 class=widget-title>Tag cloud</h3><div class="widget tagcloud"><a href=https://www.romange.com/tags/asynchronous style=font-size:12px>asynchronous</a>
<a href=https://www.romange.com/tags/backend style=font-size:12px>backend</a>
<a href=https://www.romange.com/tags/blogging style=font-size:12px>blogging</a>
<a href=https://www.romange.com/tags/c++ style=font-size:12px>c++</a>
<a href=https://www.romange.com/tags/code-generation style=font-size:12px>code-generation</a>
<a href=https://www.romange.com/tags/concurrency style=font-size:12px>concurrency</a>
<a href=https://www.romange.com/tags/dragonfly style=font-size:12px>dragonfly</a>
<a href=https://www.romange.com/tags/fibers style=font-size:12px>fibers</a>
<a href=https://www.romange.com/tags/gaia style=font-size:12px>gaia</a>
<a href=https://www.romange.com/tags/linux style=font-size:12px>linux</a>
<a href=https://www.romange.com/tags/mapreduce style=font-size:12px>mapreduce</a>
<a href=https://www.romange.com/tags/posix style=font-size:12px>posix</a>
<a href=https://www.romange.com/tags/programming style=font-size:12px>programming</a>
<a href=https://www.romange.com/tags/reactive style=font-size:12px>reactive</a>
<a href=https://www.romange.com/tags/redis style=font-size:12px>redis</a>
<a href=https://www.romange.com/tags/seastar style=font-size:12px>seastar</a></div></div><div id=toTop class="fa fa-angle-up"></div></aside></div></div><footer id=footer><div class=outer><div id=footer-info class=inner>&copy; 2022
Roman Gershman</div></div></footer><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-107146718-1","auto"),ga("send","pageview"))</script><script src=https://www.romange.com/fancybox/jquery.fancybox.pack.js></script>
<script src=https://www.romange.com/js/script.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js></script>
<script>hljs.initHighlightingOnLoad()</script><script type=text/x-mathjax-config>
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>